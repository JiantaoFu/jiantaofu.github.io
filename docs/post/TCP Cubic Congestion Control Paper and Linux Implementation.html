<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <script src='https://blog.meekdai.com/Gmeek/plugins/GmeekVercount.js'></script>
    <link rel="icon" href="https://www.gravatar.com/avatar/b2e648e70e0d3d2b8970e089ec487bc9?s=200&d=identicon&r=g"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="# Paper

use a cubic function to replace the linear window growth to improve performance in high BDP network, also achieved RTT fairness.

tcp-cubic is succssor of tcp-bic, tcp-bic use binary search to find the avialble bandwidth when congestion happens, and MAY enter an lieaner increasing state (Additive Increase)if it dropped too low, if it passed the maximum window, it goes into max probing state and will do the reverse and grow slowly initially and switch to additive increase if it can't find new maximum window nearby.

The problem with tcp-bic is that the growth function is too aggressive for short RTT or low speed network, and different phases (additive increase, binary search, max probing) add complexity in implememting and analyzing.

tcp-cubic is replacing the phase functions with a unified one function, which is a cubic function of the elapsed time from the last congestion event.

for the tcp-cubic function, we can start with `w=t^^3`, which gives the initial shape center at (0, 0), then we can move the center towards the right to K, which gives `w = (t-K)^^3`, and then move the center upwards to Wmax, then we have `w = (t-K)^^3 + Wmax`, and we can tune the shape via parameter C, the larger C, more aggressive on the steps, now we have **equation (1)** `w = C*(t-K)^^3 + Wmax`.

Say if now we have congestion and the congestion window drops from `Wmax` to `Wmax*(1 - beta)`, beta is the window decrease factor. And we assume this point is `(0, Wmax*(1 - beta)`, then K is actually the time it takes to ramp up back to Wmax. and we can get the **equation (2)**:

```
cwnd = Wmax - Wmax * beta = C * (0 - K)^^3 + Wmax
=>  Wmax * beta = C * K^^3 
=>  K = (Wmax * beta / C)^^(1/3)
```

That is how we get the eqaution (1) and (2) in the paper.

In each RTT period, we calcuate curent Window size using equation (1), `W_curr = W(t + RTT)`.

The current window might be to small compared with traditional TCP, and might cause friendly issue(actually no wrose than traditional TCP in anyway), so it will give an estimation of the traditional TCP congestion window after time t, and if the window calcualated using cubic function is smaller than that, it will use the traditional TCP congestion window.

To make it fairness with traditional TCP, we should get similar average window size. 

The average window size of AIMD additive increase (alpha) and multplicative decrease (beta) is give as `sqrt[alpha/2 * (2-beta)/beta / p] / RTT`, for tcp alpha = 1 and beta = 0.5, so we have average window size for traditional TCP `sqrt(3/2/p) / RTT`. Since now in use different beta (0.2) for cubic, to get similiar average window size, the alpha should be `3 * beta / (2 - beta)`, and we can caculate the window size if using AIMD with alpha and beta, given the elapsed time t since last decrease.

```
Wtcp = Wmax * (1-beta) + alpha * t / RTT = Wmax * (1-beta) + 3 * beta / (2-beta) * t / RTT
```

fast convergence is used to let new flow to get its fair share more quickly, the idea is that when loss event occurrs, if the Wmax keeps dropping (less than before), it will reduce more to apply a factor `1 - beta/2` (that is * 0.9), so that the flow have the plateau earlier to give other flows more chance to catch up.

# Linux implementation

At a first glance, the Linux implementation looks more complicate than the paper, the reason is that for kernel peformance, for example it convert all the float number operation into integer by scaling, and also the congestion avoidance implementation is actually increase the congestion window by 1 every N ACKs, it won't be able to increase by a float number calculated using the equation (1), we have to calculate a N to approximate that to achieve similar effect, and need to consider the effect of delay-ack. Another confusing thing is that the beta in linux implementation is actually 1-beta in the paper. The code also include the hystart slow start algorithm which is not in the cubic paper.

First, let's see how the code use the equations above, the first thing is when there is a packet drop, it will update `ssthresh` and `last_max_cwnd`, beta is 717 and BICTCP_BETA_SCALE is 1024, beta/BICTCP_BETA_SCALE = 0.7, so the `snd_ssthresh` will drop to `0.7 * snd_cwnd`. And `snd_cwnd` will be updated based on the state of TCP (todo add more details, see tcp_input.c)

If no fast convergence, `last_max_cwnd` will set to the current `snd_cwnd`, otherwise it will apply another factor: `(BICTCP_BETA_SCALE + beta) / (2 * BICTCP_BETA_SCALE) = (1+beta_before_scaled)/2 = (1+1-beta_in_paper)/2 = (2 - beta_in_paper)/2 = (1 - beta_in_paper/2`

```
static u32 bictcp_recalc_ssthresh(struct sock *sk)
{
	const struct tcp_sock *tp = tcp_sk(sk);
	struct bictcp *ca = inet_csk_ca(sk);

	ca->epoch_start = 0;	/* end of epoch */

	/* Wmax and fast convergence */
	if (tp->snd_cwnd < ca->last_max_cwnd && fast_convergence)
		ca->last_max_cwnd = (tp->snd_cwnd * (BICTCP_BETA_SCALE + beta))
			/ (2 * BICTCP_BETA_SCALE);
	else
		ca->last_max_cwnd = tp->snd_cwnd;

	ca->loss_cwnd = tp->snd_cwnd;

	return max((tp->snd_cwnd * beta) / BICTCP_BETA_SCALE, 2U);
}
```

When get ack, it will calculate a moving average of delayed acked packet count `delayed_ack`, `ACK_RATIO_SHIFT`(default to 4) is the moving average factor and `cnt` is the delayed acked packet count in current ACK. `delayed_ack` will be used later to update congestion window, in the paper it assumes that we update congestion window on each ACK per RTT, and delayed ack might gives longer interval per ACK, and we need compensate for that.

The following code is actuall doing the math `ratio = (15*ratio + sample) / 16`, `delayed_ack`(ratio) is initilized to be 16 times larger `ca->delayed_ack = 2 << ACK_RATIO_SHIFT;`, if the last value is X without scaling by 16 times (`ratio = 16 * X`), then `15 * ratio / 16 + cnt = 15 * 16 * X / 16 + cnt = 15 * X + cnt`, `15 * ratio / 16 + cnt` is what used in the code below, and if we check the above equation in reverse direction: moving average of the raw value X without scaling is `(15 * X + cnt) / 16 = (15 * 16 * X / 16 + cnt) / 16 = (15 * ratio / 16 + cnt) / 16`, that is we can calculate moving average X using the scaled value ratio, and we need `* 16` to convert the raw value to `ratio` for next iteration, and store that in `delayed_ack`, so the `delayed_ack` is actually the moving avarege of scaled value.

```
static void bictcp_acked(struct sock *sk, u32 cnt, s32 rtt_us)
{
    ......
                u32 ratio = ca->delayed_ack;
		ratio -= ca->delayed_ack >> ACK_RATIO_SHIFT;
		ratio += cnt;
		ca->delayed_ack = min(ratio, ACK_RATIO_LIMIT);
    ......
}
```

If the current `snd_cwnd` is no larger than `snd_ssthresh` it will enter into slow start, can either use the traditional slow start or hystart based on the settings, otherwise, it will enter into congestion avoidance, this is what cubic does most of its job:

If current `cwnd` is larger than `last_max_cwnd`, will reset the origin point to `cwnd`, and reset `bic_K` to zero, this is the max probing state. Else it's in steady state, and will compute new K, the estimate time needed to reach `last_max_cwnd`, we can rewrite equation 2 `cwnd = Wmax - Wmax * beta = C * (0 - K)^^3 + Wmax => K = [(Wmax - cwnd) / C]^^(1/3)`, this is the equation used in the code.

```
    if (ca->last_max_cwnd <= cwnd) {
			ca->bic_K = 0;
			ca->bic_origin_point = cwnd;
		} else {
			/* Compute new K based on
			 * (wmax-cwnd) * (srtt>>3 / HZ) / c * 2^(3*bictcp_HZ)
			 */
			ca->bic_K = cubic_root(cube_factor
					       * (ca->last_max_cwnd - cwnd));
			ca->bic_origin_point = ca->last_max_cwnd;
		}
```

should be notice that the unit of bic_K (same for the elapsed time since epoch) is not ms nor jiffies(HZ), it's using `BHZ = HZ*(2^^BICTCP_HZ) = HZ*(2^^10) = HZ*1024`, to avoid overflow when doing the math.

The C used is actually `bic_scale * 10 / 1024 =  41 * 10 / 1024 =  0.4`, and in order to convert the time to units of BHZ, `bic_K (HZ) = cubic_root(1/C * (last_max_cwnd - cwnd)) => bic_K (BHz) * 2^^BICTCP_HZ = 2^^BICTCP_HZ * cubic_root(1/C * (last_max_cwnd - cwnd)) = cubic_root((2^^BICTCP_HZ)^^3 * 1/C * (last_max_cwnd - cwnd)) = cubic_root(2^^(3*BICTCP_HZ) * 1/C * (last_max_cwnd - cwnd)) = cubic_root(2^^(3*BICTCP_HZ) * 2^^10/(bic_scale*10) * (last_max_cwnd - cwnd))`

`2^^(3*BICTCP_HZ) * 2^^10/(bic_scale*10) = 2^^(3*BICTCP_HZ+10)/(bic_scale*10) = 1ull << (10+3*BICTCP_HZ)/(bic_scale*10)`, this is how `cube_factor` is caculated.

```
cube_factor = 1ull << (10+3*BICTCP_HZ);
do_div(cube_factor, bic_scale * 10);
```

Then we will caculate the elapsed time plus one RTT in unit BHZ, and then caculate the target congestion window, for calculating delta of congestion window, `delta = (cube_rtt_scale * offs * offs * offs) >> (10+3*BICTCP_HZ);`, since the `offset` is in BHZ, to convert it back to HZ, we need `/ (2^^BICTCP_HZ)`, that is `>>BICTCP_HZ`, and we have multiplied 3 offset, so it's converting 'BHZ * BHZ * BHZ' back to 'HZ * HZ * HZ', that is `/(2^^BICTCP_HZ)^^3 = /(2^^(3*BICTCP_HZ) = >>(3*BICTCP_HZ)`, and `C = cube_rtt_scale/1024 = cube_rtt_scale >> 10`.

so `delta = C * offs * offs * offs >> (3+BICTCP_HZ) = cube_rtt_scale * offs * offs * offs >> (10+3*BICTCP_HZ)`

```
	t = ((tcp_time_stamp + msecs_to_jiffies(ca->delay_min>>3)
	      - ca->epoch_start) << BICTCP_HZ) / HZ;

	if (t < ca->bic_K)		/* t - K */
		offs = ca->bic_K - t;
	else
		offs = t - ca->bic_K;

	/* c/rtt * (t-K)^3 */
	delta = (cube_rtt_scale * offs * offs * offs) >> (10+3*BICTCP_HZ);
	if (t < ca->bic_K)                                	/* below origin*/
		bic_target = ca->bic_origin_point - delta;
	else                                                	/* above origin*/
		bic_target = ca->bic_origin_point + delta
```

Once we have `bic_target`, we can calculate the congestion window increment for each RTT, `tcp_cong_avoid_ai` is called for each ACK, and it will increase `snd_cwnd` by 1 on every `w` ACKs (that is increase by `1/w` on each ACK), for TCP reno `w` is the congestion window, that is increment by 1 for each RTT (receive `w` ACKs when `w` packets send out in one RTT).

```
/* In theory this is tp->snd_cwnd += 1 / tp->snd_cwnd (or alternative w) */
void tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w)
{
	if (tp->snd_cwnd_cnt >= w) {
		if (tp->snd_cwnd < tp->snd_cwnd_clamp)
			tp->snd_cwnd++;
		tp->snd_cwnd_cnt = 0;
	} else {
		tp->snd_cwnd_cnt++;
	}
}
```

For cubic, we are expecting to increase the congestion window by `bic_target - cwnd` in the next round trip time, since we will send out `cwnd` packets in one RTT, if we don't consider delayed ack and assume ack per packet, then it's for each ACK the congestion window increases by `(bic_target - cwnd)/cwnd`, then `(bic_target - cwnd)/cwnd = 1/w => w = cwnd/ (bic_target - cwnd)`, which is exactly what we have for `ca->cnt` when `bic_target > cwnd`, if it's smaller, then the increment will be very small, `1/(100 * cwnd)` on each ACK, that is `1/100` on each RTT if no delay ACK, this is just a safety guard.

```
	/* cubic function - calc bictcp_cnt*/
	if (bic_target > cwnd) {
		ca->cnt = cwnd / (bic_target - cwnd);
	} else {
		ca->cnt = 100 * cwnd;              /* very small increment*/
	}
	
	...
	tcp_cong_avoid_ai(tp, ca->cnt);
```

And if we consider the delay ack, we should compensate for that b/c we may get less Ack when using delay ack, which means for each ACK we should increase more, that said if no delay ACK, we increase `1/ca->cnt` per ACK (w = ca->cnt), then with delay ACK, assume we have pkts_per_ack, we should increase `pkts_per_ack/ca->cnt` per ACK (w = ca->cnt/pktsPerAck . `delayed_ack` is a scaled value, then `pkts_per_ack = delayed_ack/16`

```
ca->cnt = (ca->cnt << ACK_RATIO_SHIFT) / ca->delayed_ack;
```

To avoid the case cubic is slower than TCP, it will estimated the congestion window of traditional TCP. In the paper we have the increament factor `alpha = 3 * beta_in_paper / (2-beta_in_paper)`, since in the code the beta is actual `1-beta_in_paper`, then `alpha = 3 * (1 - beta) / (1 + beta)`.

in the code, `beta_scale = 8 / alpha`, 8 is just another scaling factor which ensure beta_scale is integer, and for later use it will apply `>>3` which give `1 / alpha`.

```
beta_scale = 8*(BICTCP_BETA_SCALE+beta)/ 3 / (BICTCP_BETA_SCALE - beta);
```

When `tcp_friendliness` enabled, to simulate traditional TCP, the congestion window increase per RTT is `alpha`, so for each ACK, the increment `1/w` is `alpha/cwnd = 8/(beta_scale * cwnd)`, so we have `w = beta_scale * cwnd / 8 = beta_scale * cwnd >> 3`. That is every `w` ACK packets the congestion window increment by 1, give current has `ca->ack_cnt` acks in total, we can estimate `tcp_cwnd`.

once we have `tcp_cwnd`, if it's larger than current `cwnd`, we should increase cwnd by `delta = tcp_cwnd - cwnd`, and we use the max between `bic_target` and `tcp_cwnd`, the code is using smaller cnt but it's actually the same.

```
	/* TCP Friendly */
	if (tcp_friendliness) {
		u32 scale = beta_scale;
		delta = (cwnd * scale) >> 3;
		while (ca->ack_cnt > delta) {		/* update tcp cwnd */
			ca->ack_cnt -= delta;
			ca->tcp_cwnd++;
		}

		if (ca->tcp_cwnd > cwnd){	/* if bic is slower than tcp */
			delta = ca->tcp_cwnd - cwnd;
			max_cnt = cwnd / delta;
			if (ca->cnt > max_cnt)
				ca->cnt = max_cnt;
		}
	}
```

# Hystart

Linux implementation also use hystart slow start by default, hystart slow start is to exit early to avoid too many packet loss caused by slow start phase, and it utilize the packet train and delay to give hint when to stop slow start. Since for most TCP it's window based and data are send out in a burst in one congestion window, which means we can use those packets as packet train, suppose we send out N packets in the train, the time gap between the 1st and Nst packet is delta(N), then the bandwidth estimation will be `bw = (N-1) * packet_length / delta(N)`,  the network pipe capcaity (without buffer) is `K = bw * one_way_delay_min`, the data sent in a cwnd should be no larger than the pipe capacity.

```
(N-1) * packet_length <= bw * one_way_delay_min = (N-1) * packet_length / delta(N) * one_way_delay_min
=> delta(N) <= one_way_delay_min
```

That means we can measure the time gap of the train to know whether we are exceed the available bandwidth and enter into congestion avoidance. Since it's not easy to measure one way delay, half of RTT is used, and to avoid modification on both sides, ACK gap between Nst and 1st packet is used. 

Using RTT/2 as one way delay estimation won't make things worse,  exit too early will cause under untilization, `beta * (bw * one_way_delay_min)` can be used as the lowerbound for safety exit, for standard TCP, beta is 0.5, other variances has beta larger than 0.5;

suppose we have forward and backward delay `a` and `b`, if we use `RTT/2 = (a+b)/2` as one way delay, the BDP estimation `K' = bw * (a+b)/2` while `K =  bw * a`, `K'/K = (a + b) / 2 / a = 1/2 + b/2/a >= 1/2`, so we have `K' >= 0.5 * K`, that is to say if we use RTT/2 as estimation, the BDP estimations is no less than half of the real BDP, so we won't exit slow start before we reach 0.5 * BDP (threshold of the standard TCP slow start).  

And if it congestin window goes beyond `K + S`(S is network buffer size), which is the upper bound of safety exit, packet will be dropped, so we have `K'/K = 1/2 + b/2/a <= (K + S)/K => 1/2 + b/2/a <= 1 + S/K`, if `S=K`, then `1/2 + b/2/a <= 2 => b/a <= 3 => b <= 3a`, and there are less than 5% cases that has reverse path delay larger than forward path, which means in this case, the slow start will fallback to traditional slow start which overshoots and cause packet loss.

Using Ack may give larger time gap, which gives lower bandwidth estimation, and cause conservative behavior to exit slow start earlier. Delay Ack also affect the accuracy, so if there is significantly delay in the last ACK, that sample is filter out and mixed with next train.

And there may be cases that minimum RTT is not available, for example when multiple flows are competing, the idea is use delay increasing as an exit indicator, it measure the first a few packets of the train, and calculate the average RTT for that train, and compare the trian K and train K-1, if RTT(K) > RTT(K-1) + delta, then exit slow start.

The Linux implementation is slightly different and simpler than that in the paper.

Hystart will be triggered when the cwnd is larger than `hystart_low_window` (default to 16)

```
	/* hystart triggers when cwnd is larger than some threshold */
	if (hystart && tp->snd_cwnd <= tp->snd_ssthresh &&
	    tp->snd_cwnd >= hystart_low_window)
		hystart_update(sk, delay);
```

It will keep track to minimum delay(`delay_min`) in the tcp session so far. On each ACK, it will check if the time since last ACK is less than the threshold `hystart_ack_delta` to filter the invalid sample, if it's invalid, then in this round, it will not do ack train detection, and if the sample is valid, check if it goes beyond minRTT/2 (`delay_min` is scaled by 8, so `>>4` is actually minRTT/2), if so it will detect as `HYSTART_ACK_TRAIN` happens.

It also track minimum delay(`curr_delay`) among the first `HYSTART_MIN_SAMPLES` samples in each round (send cwnd packets in the burst train). It `curr_delay` is larger than `delay_min` more than a threshold value, which is `delay_min/2`, clamp to `[4, 16] ms`, then it will detect as `HYSTART_DELAY`.

Either one detected will cause the slow start exit by setting the `ssthresh` to current congeston window `snd_cwnd`.

```
static void hystart_update(struct sock *sk, u32 delay)
{
	struct tcp_sock *tp = tcp_sk(sk);
	struct bictcp *ca = inet_csk_ca(sk);

	if (!(ca->found & hystart_detect)) {
		u32 now = bictcp_clock();

		/* first detection parameter - ack-train detection */
		if ((s32)(now - ca->last_ack) <= hystart_ack_delta) {
			ca->last_ack = now;
			if ((s32)(now - ca->round_start) > ca->delay_min >> 4)
				ca->found |= HYSTART_ACK_TRAIN;
		}

		/* obtain the minimum delay of more than sampling packets */
		if (ca->sample_cnt < HYSTART_MIN_SAMPLES) {
			if (ca->curr_rtt == 0 || ca->curr_rtt > delay)
				ca->curr_rtt = delay;

			ca->sample_cnt++;
		} else {
			if (ca->curr_rtt > ca->delay_min +
			    HYSTART_DELAY_THRESH(ca->delay_min>>4))
				ca->found |= HYSTART_DELAY;
		}
		/*
		 * Either one of two conditions are met,
		 * we exit from slow start immediately.
		 */
		if (ca->found & hystart_detect)
			tp->snd_ssthresh = tp->snd_cwnd;
	}
}
```

# Tuning parameters

Linux cubic implementation has some parameters which can be used to tune the algorithm, by set different values for files (filename is the same with parameter name) in `/sys/module/tcp_cubic/parameters/`

- fast_convergence: default is on. enable fast convergence will degrade more when consecutive downgrade, this is used for let new comers to get fair share faster. 

- beta: beta is used for multiplicative decrease, larger value will decrease less, default is 0.7, that is 0.7 * cwnd when loss happens. beta will also affect the fairness with standard TCP. beta is scaled by 1024.

- initial_ssthresh: use to set the initial ssthresh value, only used at the beginning whe hystart not enabled.

- bic_scale: bi_scale is used to tune the cubic funtion curve (C in the equation 1), large beta will increase more aggressively, default is 0.4. bic_scale also affect teh fairness with standard TCP. bic_scale is scaled by 1024.

- tcp_friendliness: used to ensure in any case cubic is no worse than standard TCP. default is on.

- hystart: enable hystart, which exit slow start earlier based on delay to avoid too much packet loss.

- hystart_detect: enable which methods are used for hystart detection, default is enable both packet train and delay increase.

- hystart_low_window: when cwnd is larger than hystart_low_window, will start hystart slow start. default is 16.

- hystart_ack_delta: threshold value to filter delay ACK, default is 2.

```
module_param(fast_convergence, int, 0644);
MODULE_PARM_DESC(fast_convergence, 'turn on/off fast convergence');
module_param(beta, int, 0644);
MODULE_PARM_DESC(beta, 'beta for multiplicative increase');
module_param(initial_ssthresh, int, 0644);
MODULE_PARM_DESC(initial_ssthresh, 'initial value of slow start threshold');
module_param(bic_scale, int, 0444);
MODULE_PARM_DESC(bic_scale, 'scale (scaled by 1024) value for bic function (bic_scale/1024)');
module_param(tcp_friendliness, int, 0644);
MODULE_PARM_DESC(tcp_friendliness, 'turn on/off tcp friendliness');
module_param(hystart, int, 0644);
MODULE_PARM_DESC(hystart, 'turn on/off hybrid slow start algorithm');
module_param(hystart_detect, int, 0644);
MODULE_PARM_DESC(hystart_detect, 'hyrbrid slow start detection mechanisms'
		 ' 1: packet-train 2: delay 3: both packet-train and delay');
module_param(hystart_low_window, int, 0644);
MODULE_PARM_DESC(hystart_low_window, 'lower bound cwnd for hybrid slow start');
module_param(hystart_ack_delta, int, 0644);
MODULE_PARM_DESC(hystart_ack_delta, 'spacing between ack's indicating train (msecs)');
```。">
<meta property="og:title" content="TCP Cubic Congestion Control Paper and Linux Implementation">
<meta property="og:description" content="# Paper

use a cubic function to replace the linear window growth to improve performance in high BDP network, also achieved RTT fairness.

tcp-cubic is succssor of tcp-bic, tcp-bic use binary search to find the avialble bandwidth when congestion happens, and MAY enter an lieaner increasing state (Additive Increase)if it dropped too low, if it passed the maximum window, it goes into max probing state and will do the reverse and grow slowly initially and switch to additive increase if it can't find new maximum window nearby.

The problem with tcp-bic is that the growth function is too aggressive for short RTT or low speed network, and different phases (additive increase, binary search, max probing) add complexity in implememting and analyzing.

tcp-cubic is replacing the phase functions with a unified one function, which is a cubic function of the elapsed time from the last congestion event.

for the tcp-cubic function, we can start with `w=t^^3`, which gives the initial shape center at (0, 0), then we can move the center towards the right to K, which gives `w = (t-K)^^3`, and then move the center upwards to Wmax, then we have `w = (t-K)^^3 + Wmax`, and we can tune the shape via parameter C, the larger C, more aggressive on the steps, now we have **equation (1)** `w = C*(t-K)^^3 + Wmax`.

Say if now we have congestion and the congestion window drops from `Wmax` to `Wmax*(1 - beta)`, beta is the window decrease factor. And we assume this point is `(0, Wmax*(1 - beta)`, then K is actually the time it takes to ramp up back to Wmax. and we can get the **equation (2)**:

```
cwnd = Wmax - Wmax * beta = C * (0 - K)^^3 + Wmax
=>  Wmax * beta = C * K^^3 
=>  K = (Wmax * beta / C)^^(1/3)
```

That is how we get the eqaution (1) and (2) in the paper.

In each RTT period, we calcuate curent Window size using equation (1), `W_curr = W(t + RTT)`.

The current window might be to small compared with traditional TCP, and might cause friendly issue(actually no wrose than traditional TCP in anyway), so it will give an estimation of the traditional TCP congestion window after time t, and if the window calcualated using cubic function is smaller than that, it will use the traditional TCP congestion window.

To make it fairness with traditional TCP, we should get similar average window size. 

The average window size of AIMD additive increase (alpha) and multplicative decrease (beta) is give as `sqrt[alpha/2 * (2-beta)/beta / p] / RTT`, for tcp alpha = 1 and beta = 0.5, so we have average window size for traditional TCP `sqrt(3/2/p) / RTT`. Since now in use different beta (0.2) for cubic, to get similiar average window size, the alpha should be `3 * beta / (2 - beta)`, and we can caculate the window size if using AIMD with alpha and beta, given the elapsed time t since last decrease.

```
Wtcp = Wmax * (1-beta) + alpha * t / RTT = Wmax * (1-beta) + 3 * beta / (2-beta) * t / RTT
```

fast convergence is used to let new flow to get its fair share more quickly, the idea is that when loss event occurrs, if the Wmax keeps dropping (less than before), it will reduce more to apply a factor `1 - beta/2` (that is * 0.9), so that the flow have the plateau earlier to give other flows more chance to catch up.

# Linux implementation

At a first glance, the Linux implementation looks more complicate than the paper, the reason is that for kernel peformance, for example it convert all the float number operation into integer by scaling, and also the congestion avoidance implementation is actually increase the congestion window by 1 every N ACKs, it won't be able to increase by a float number calculated using the equation (1), we have to calculate a N to approximate that to achieve similar effect, and need to consider the effect of delay-ack. Another confusing thing is that the beta in linux implementation is actually 1-beta in the paper. The code also include the hystart slow start algorithm which is not in the cubic paper.

First, let's see how the code use the equations above, the first thing is when there is a packet drop, it will update `ssthresh` and `last_max_cwnd`, beta is 717 and BICTCP_BETA_SCALE is 1024, beta/BICTCP_BETA_SCALE = 0.7, so the `snd_ssthresh` will drop to `0.7 * snd_cwnd`. And `snd_cwnd` will be updated based on the state of TCP (todo add more details, see tcp_input.c)

If no fast convergence, `last_max_cwnd` will set to the current `snd_cwnd`, otherwise it will apply another factor: `(BICTCP_BETA_SCALE + beta) / (2 * BICTCP_BETA_SCALE) = (1+beta_before_scaled)/2 = (1+1-beta_in_paper)/2 = (2 - beta_in_paper)/2 = (1 - beta_in_paper/2`

```
static u32 bictcp_recalc_ssthresh(struct sock *sk)
{
	const struct tcp_sock *tp = tcp_sk(sk);
	struct bictcp *ca = inet_csk_ca(sk);

	ca->epoch_start = 0;	/* end of epoch */

	/* Wmax and fast convergence */
	if (tp->snd_cwnd < ca->last_max_cwnd && fast_convergence)
		ca->last_max_cwnd = (tp->snd_cwnd * (BICTCP_BETA_SCALE + beta))
			/ (2 * BICTCP_BETA_SCALE);
	else
		ca->last_max_cwnd = tp->snd_cwnd;

	ca->loss_cwnd = tp->snd_cwnd;

	return max((tp->snd_cwnd * beta) / BICTCP_BETA_SCALE, 2U);
}
```

When get ack, it will calculate a moving average of delayed acked packet count `delayed_ack`, `ACK_RATIO_SHIFT`(default to 4) is the moving average factor and `cnt` is the delayed acked packet count in current ACK. `delayed_ack` will be used later to update congestion window, in the paper it assumes that we update congestion window on each ACK per RTT, and delayed ack might gives longer interval per ACK, and we need compensate for that.

The following code is actuall doing the math `ratio = (15*ratio + sample) / 16`, `delayed_ack`(ratio) is initilized to be 16 times larger `ca->delayed_ack = 2 << ACK_RATIO_SHIFT;`, if the last value is X without scaling by 16 times (`ratio = 16 * X`), then `15 * ratio / 16 + cnt = 15 * 16 * X / 16 + cnt = 15 * X + cnt`, `15 * ratio / 16 + cnt` is what used in the code below, and if we check the above equation in reverse direction: moving average of the raw value X without scaling is `(15 * X + cnt) / 16 = (15 * 16 * X / 16 + cnt) / 16 = (15 * ratio / 16 + cnt) / 16`, that is we can calculate moving average X using the scaled value ratio, and we need `* 16` to convert the raw value to `ratio` for next iteration, and store that in `delayed_ack`, so the `delayed_ack` is actually the moving avarege of scaled value.

```
static void bictcp_acked(struct sock *sk, u32 cnt, s32 rtt_us)
{
    ......
                u32 ratio = ca->delayed_ack;
		ratio -= ca->delayed_ack >> ACK_RATIO_SHIFT;
		ratio += cnt;
		ca->delayed_ack = min(ratio, ACK_RATIO_LIMIT);
    ......
}
```

If the current `snd_cwnd` is no larger than `snd_ssthresh` it will enter into slow start, can either use the traditional slow start or hystart based on the settings, otherwise, it will enter into congestion avoidance, this is what cubic does most of its job:

If current `cwnd` is larger than `last_max_cwnd`, will reset the origin point to `cwnd`, and reset `bic_K` to zero, this is the max probing state. Else it's in steady state, and will compute new K, the estimate time needed to reach `last_max_cwnd`, we can rewrite equation 2 `cwnd = Wmax - Wmax * beta = C * (0 - K)^^3 + Wmax => K = [(Wmax - cwnd) / C]^^(1/3)`, this is the equation used in the code.

```
    if (ca->last_max_cwnd <= cwnd) {
			ca->bic_K = 0;
			ca->bic_origin_point = cwnd;
		} else {
			/* Compute new K based on
			 * (wmax-cwnd) * (srtt>>3 / HZ) / c * 2^(3*bictcp_HZ)
			 */
			ca->bic_K = cubic_root(cube_factor
					       * (ca->last_max_cwnd - cwnd));
			ca->bic_origin_point = ca->last_max_cwnd;
		}
```

should be notice that the unit of bic_K (same for the elapsed time since epoch) is not ms nor jiffies(HZ), it's using `BHZ = HZ*(2^^BICTCP_HZ) = HZ*(2^^10) = HZ*1024`, to avoid overflow when doing the math.

The C used is actually `bic_scale * 10 / 1024 =  41 * 10 / 1024 =  0.4`, and in order to convert the time to units of BHZ, `bic_K (HZ) = cubic_root(1/C * (last_max_cwnd - cwnd)) => bic_K (BHz) * 2^^BICTCP_HZ = 2^^BICTCP_HZ * cubic_root(1/C * (last_max_cwnd - cwnd)) = cubic_root((2^^BICTCP_HZ)^^3 * 1/C * (last_max_cwnd - cwnd)) = cubic_root(2^^(3*BICTCP_HZ) * 1/C * (last_max_cwnd - cwnd)) = cubic_root(2^^(3*BICTCP_HZ) * 2^^10/(bic_scale*10) * (last_max_cwnd - cwnd))`

`2^^(3*BICTCP_HZ) * 2^^10/(bic_scale*10) = 2^^(3*BICTCP_HZ+10)/(bic_scale*10) = 1ull << (10+3*BICTCP_HZ)/(bic_scale*10)`, this is how `cube_factor` is caculated.

```
cube_factor = 1ull << (10+3*BICTCP_HZ);
do_div(cube_factor, bic_scale * 10);
```

Then we will caculate the elapsed time plus one RTT in unit BHZ, and then caculate the target congestion window, for calculating delta of congestion window, `delta = (cube_rtt_scale * offs * offs * offs) >> (10+3*BICTCP_HZ);`, since the `offset` is in BHZ, to convert it back to HZ, we need `/ (2^^BICTCP_HZ)`, that is `>>BICTCP_HZ`, and we have multiplied 3 offset, so it's converting 'BHZ * BHZ * BHZ' back to 'HZ * HZ * HZ', that is `/(2^^BICTCP_HZ)^^3 = /(2^^(3*BICTCP_HZ) = >>(3*BICTCP_HZ)`, and `C = cube_rtt_scale/1024 = cube_rtt_scale >> 10`.

so `delta = C * offs * offs * offs >> (3+BICTCP_HZ) = cube_rtt_scale * offs * offs * offs >> (10+3*BICTCP_HZ)`

```
	t = ((tcp_time_stamp + msecs_to_jiffies(ca->delay_min>>3)
	      - ca->epoch_start) << BICTCP_HZ) / HZ;

	if (t < ca->bic_K)		/* t - K */
		offs = ca->bic_K - t;
	else
		offs = t - ca->bic_K;

	/* c/rtt * (t-K)^3 */
	delta = (cube_rtt_scale * offs * offs * offs) >> (10+3*BICTCP_HZ);
	if (t < ca->bic_K)                                	/* below origin*/
		bic_target = ca->bic_origin_point - delta;
	else                                                	/* above origin*/
		bic_target = ca->bic_origin_point + delta
```

Once we have `bic_target`, we can calculate the congestion window increment for each RTT, `tcp_cong_avoid_ai` is called for each ACK, and it will increase `snd_cwnd` by 1 on every `w` ACKs (that is increase by `1/w` on each ACK), for TCP reno `w` is the congestion window, that is increment by 1 for each RTT (receive `w` ACKs when `w` packets send out in one RTT).

```
/* In theory this is tp->snd_cwnd += 1 / tp->snd_cwnd (or alternative w) */
void tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w)
{
	if (tp->snd_cwnd_cnt >= w) {
		if (tp->snd_cwnd < tp->snd_cwnd_clamp)
			tp->snd_cwnd++;
		tp->snd_cwnd_cnt = 0;
	} else {
		tp->snd_cwnd_cnt++;
	}
}
```

For cubic, we are expecting to increase the congestion window by `bic_target - cwnd` in the next round trip time, since we will send out `cwnd` packets in one RTT, if we don't consider delayed ack and assume ack per packet, then it's for each ACK the congestion window increases by `(bic_target - cwnd)/cwnd`, then `(bic_target - cwnd)/cwnd = 1/w => w = cwnd/ (bic_target - cwnd)`, which is exactly what we have for `ca->cnt` when `bic_target > cwnd`, if it's smaller, then the increment will be very small, `1/(100 * cwnd)` on each ACK, that is `1/100` on each RTT if no delay ACK, this is just a safety guard.

```
	/* cubic function - calc bictcp_cnt*/
	if (bic_target > cwnd) {
		ca->cnt = cwnd / (bic_target - cwnd);
	} else {
		ca->cnt = 100 * cwnd;              /* very small increment*/
	}
	
	...
	tcp_cong_avoid_ai(tp, ca->cnt);
```

And if we consider the delay ack, we should compensate for that b/c we may get less Ack when using delay ack, which means for each ACK we should increase more, that said if no delay ACK, we increase `1/ca->cnt` per ACK (w = ca->cnt), then with delay ACK, assume we have pkts_per_ack, we should increase `pkts_per_ack/ca->cnt` per ACK (w = ca->cnt/pktsPerAck . `delayed_ack` is a scaled value, then `pkts_per_ack = delayed_ack/16`

```
ca->cnt = (ca->cnt << ACK_RATIO_SHIFT) / ca->delayed_ack;
```

To avoid the case cubic is slower than TCP, it will estimated the congestion window of traditional TCP. In the paper we have the increament factor `alpha = 3 * beta_in_paper / (2-beta_in_paper)`, since in the code the beta is actual `1-beta_in_paper`, then `alpha = 3 * (1 - beta) / (1 + beta)`.

in the code, `beta_scale = 8 / alpha`, 8 is just another scaling factor which ensure beta_scale is integer, and for later use it will apply `>>3` which give `1 / alpha`.

```
beta_scale = 8*(BICTCP_BETA_SCALE+beta)/ 3 / (BICTCP_BETA_SCALE - beta);
```

When `tcp_friendliness` enabled, to simulate traditional TCP, the congestion window increase per RTT is `alpha`, so for each ACK, the increment `1/w` is `alpha/cwnd = 8/(beta_scale * cwnd)`, so we have `w = beta_scale * cwnd / 8 = beta_scale * cwnd >> 3`. That is every `w` ACK packets the congestion window increment by 1, give current has `ca->ack_cnt` acks in total, we can estimate `tcp_cwnd`.

once we have `tcp_cwnd`, if it's larger than current `cwnd`, we should increase cwnd by `delta = tcp_cwnd - cwnd`, and we use the max between `bic_target` and `tcp_cwnd`, the code is using smaller cnt but it's actually the same.

```
	/* TCP Friendly */
	if (tcp_friendliness) {
		u32 scale = beta_scale;
		delta = (cwnd * scale) >> 3;
		while (ca->ack_cnt > delta) {		/* update tcp cwnd */
			ca->ack_cnt -= delta;
			ca->tcp_cwnd++;
		}

		if (ca->tcp_cwnd > cwnd){	/* if bic is slower than tcp */
			delta = ca->tcp_cwnd - cwnd;
			max_cnt = cwnd / delta;
			if (ca->cnt > max_cnt)
				ca->cnt = max_cnt;
		}
	}
```

# Hystart

Linux implementation also use hystart slow start by default, hystart slow start is to exit early to avoid too many packet loss caused by slow start phase, and it utilize the packet train and delay to give hint when to stop slow start. Since for most TCP it's window based and data are send out in a burst in one congestion window, which means we can use those packets as packet train, suppose we send out N packets in the train, the time gap between the 1st and Nst packet is delta(N), then the bandwidth estimation will be `bw = (N-1) * packet_length / delta(N)`,  the network pipe capcaity (without buffer) is `K = bw * one_way_delay_min`, the data sent in a cwnd should be no larger than the pipe capacity.

```
(N-1) * packet_length <= bw * one_way_delay_min = (N-1) * packet_length / delta(N) * one_way_delay_min
=> delta(N) <= one_way_delay_min
```

That means we can measure the time gap of the train to know whether we are exceed the available bandwidth and enter into congestion avoidance. Since it's not easy to measure one way delay, half of RTT is used, and to avoid modification on both sides, ACK gap between Nst and 1st packet is used. 

Using RTT/2 as one way delay estimation won't make things worse,  exit too early will cause under untilization, `beta * (bw * one_way_delay_min)` can be used as the lowerbound for safety exit, for standard TCP, beta is 0.5, other variances has beta larger than 0.5;

suppose we have forward and backward delay `a` and `b`, if we use `RTT/2 = (a+b)/2` as one way delay, the BDP estimation `K' = bw * (a+b)/2` while `K =  bw * a`, `K'/K = (a + b) / 2 / a = 1/2 + b/2/a >= 1/2`, so we have `K' >= 0.5 * K`, that is to say if we use RTT/2 as estimation, the BDP estimations is no less than half of the real BDP, so we won't exit slow start before we reach 0.5 * BDP (threshold of the standard TCP slow start).  

And if it congestin window goes beyond `K + S`(S is network buffer size), which is the upper bound of safety exit, packet will be dropped, so we have `K'/K = 1/2 + b/2/a <= (K + S)/K => 1/2 + b/2/a <= 1 + S/K`, if `S=K`, then `1/2 + b/2/a <= 2 => b/a <= 3 => b <= 3a`, and there are less than 5% cases that has reverse path delay larger than forward path, which means in this case, the slow start will fallback to traditional slow start which overshoots and cause packet loss.

Using Ack may give larger time gap, which gives lower bandwidth estimation, and cause conservative behavior to exit slow start earlier. Delay Ack also affect the accuracy, so if there is significantly delay in the last ACK, that sample is filter out and mixed with next train.

And there may be cases that minimum RTT is not available, for example when multiple flows are competing, the idea is use delay increasing as an exit indicator, it measure the first a few packets of the train, and calculate the average RTT for that train, and compare the trian K and train K-1, if RTT(K) > RTT(K-1) + delta, then exit slow start.

The Linux implementation is slightly different and simpler than that in the paper.

Hystart will be triggered when the cwnd is larger than `hystart_low_window` (default to 16)

```
	/* hystart triggers when cwnd is larger than some threshold */
	if (hystart && tp->snd_cwnd <= tp->snd_ssthresh &&
	    tp->snd_cwnd >= hystart_low_window)
		hystart_update(sk, delay);
```

It will keep track to minimum delay(`delay_min`) in the tcp session so far. On each ACK, it will check if the time since last ACK is less than the threshold `hystart_ack_delta` to filter the invalid sample, if it's invalid, then in this round, it will not do ack train detection, and if the sample is valid, check if it goes beyond minRTT/2 (`delay_min` is scaled by 8, so `>>4` is actually minRTT/2), if so it will detect as `HYSTART_ACK_TRAIN` happens.

It also track minimum delay(`curr_delay`) among the first `HYSTART_MIN_SAMPLES` samples in each round (send cwnd packets in the burst train). It `curr_delay` is larger than `delay_min` more than a threshold value, which is `delay_min/2`, clamp to `[4, 16] ms`, then it will detect as `HYSTART_DELAY`.

Either one detected will cause the slow start exit by setting the `ssthresh` to current congeston window `snd_cwnd`.

```
static void hystart_update(struct sock *sk, u32 delay)
{
	struct tcp_sock *tp = tcp_sk(sk);
	struct bictcp *ca = inet_csk_ca(sk);

	if (!(ca->found & hystart_detect)) {
		u32 now = bictcp_clock();

		/* first detection parameter - ack-train detection */
		if ((s32)(now - ca->last_ack) <= hystart_ack_delta) {
			ca->last_ack = now;
			if ((s32)(now - ca->round_start) > ca->delay_min >> 4)
				ca->found |= HYSTART_ACK_TRAIN;
		}

		/* obtain the minimum delay of more than sampling packets */
		if (ca->sample_cnt < HYSTART_MIN_SAMPLES) {
			if (ca->curr_rtt == 0 || ca->curr_rtt > delay)
				ca->curr_rtt = delay;

			ca->sample_cnt++;
		} else {
			if (ca->curr_rtt > ca->delay_min +
			    HYSTART_DELAY_THRESH(ca->delay_min>>4))
				ca->found |= HYSTART_DELAY;
		}
		/*
		 * Either one of two conditions are met,
		 * we exit from slow start immediately.
		 */
		if (ca->found & hystart_detect)
			tp->snd_ssthresh = tp->snd_cwnd;
	}
}
```

# Tuning parameters

Linux cubic implementation has some parameters which can be used to tune the algorithm, by set different values for files (filename is the same with parameter name) in `/sys/module/tcp_cubic/parameters/`

- fast_convergence: default is on. enable fast convergence will degrade more when consecutive downgrade, this is used for let new comers to get fair share faster. 

- beta: beta is used for multiplicative decrease, larger value will decrease less, default is 0.7, that is 0.7 * cwnd when loss happens. beta will also affect the fairness with standard TCP. beta is scaled by 1024.

- initial_ssthresh: use to set the initial ssthresh value, only used at the beginning whe hystart not enabled.

- bic_scale: bi_scale is used to tune the cubic funtion curve (C in the equation 1), large beta will increase more aggressively, default is 0.4. bic_scale also affect teh fairness with standard TCP. bic_scale is scaled by 1024.

- tcp_friendliness: used to ensure in any case cubic is no worse than standard TCP. default is on.

- hystart: enable hystart, which exit slow start earlier based on delay to avoid too much packet loss.

- hystart_detect: enable which methods are used for hystart detection, default is enable both packet train and delay increase.

- hystart_low_window: when cwnd is larger than hystart_low_window, will start hystart slow start. default is 16.

- hystart_ack_delta: threshold value to filter delay ACK, default is 2.

```
module_param(fast_convergence, int, 0644);
MODULE_PARM_DESC(fast_convergence, 'turn on/off fast convergence');
module_param(beta, int, 0644);
MODULE_PARM_DESC(beta, 'beta for multiplicative increase');
module_param(initial_ssthresh, int, 0644);
MODULE_PARM_DESC(initial_ssthresh, 'initial value of slow start threshold');
module_param(bic_scale, int, 0444);
MODULE_PARM_DESC(bic_scale, 'scale (scaled by 1024) value for bic function (bic_scale/1024)');
module_param(tcp_friendliness, int, 0644);
MODULE_PARM_DESC(tcp_friendliness, 'turn on/off tcp friendliness');
module_param(hystart, int, 0644);
MODULE_PARM_DESC(hystart, 'turn on/off hybrid slow start algorithm');
module_param(hystart_detect, int, 0644);
MODULE_PARM_DESC(hystart_detect, 'hyrbrid slow start detection mechanisms'
		 ' 1: packet-train 2: delay 3: both packet-train and delay');
module_param(hystart_low_window, int, 0644);
MODULE_PARM_DESC(hystart_low_window, 'lower bound cwnd for hybrid slow start');
module_param(hystart_ack_delta, int, 0644);
MODULE_PARM_DESC(hystart_ack_delta, 'spacing between ack's indicating train (msecs)');
```。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://jiantaofu.github.io/post/TCP%20Cubic%20Congestion%20Control%20Paper%20and%20Linux%20Implementation.html">
<meta property="og:image" content="https://www.gravatar.com/avatar/b2e648e70e0d3d2b8970e089ec487bc9?s=200&d=identicon&r=g">
<title>TCP Cubic Congestion Control Paper and Linux Implementation</title>



</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">TCP Cubic Congestion Control Paper and Linux Implementation</h1>
<div class="title-right">
    <a href="https://jiantaofu.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/JiantaoFu/jiantaofu.github.io/issues/3" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>Paper</h1>
<p>use a cubic function to replace the linear window growth to improve performance in high BDP network, also achieved RTT fairness.</p>
<p>tcp-cubic is succssor of tcp-bic, tcp-bic use binary search to find the avialble bandwidth when congestion happens, and MAY enter an lieaner increasing state (Additive Increase)if it dropped too low, if it passed the maximum window, it goes into max probing state and will do the reverse and grow slowly initially and switch to additive increase if it can't find new maximum window nearby.</p>
<p>The problem with tcp-bic is that the growth function is too aggressive for short RTT or low speed network, and different phases (additive increase, binary search, max probing) add complexity in implememting and analyzing.</p>
<p>tcp-cubic is replacing the phase functions with a unified one function, which is a cubic function of the elapsed time from the last congestion event.</p>
<p>for the tcp-cubic function, we can start with <code class="notranslate">w=t^^3</code>, which gives the initial shape center at (0, 0), then we can move the center towards the right to K, which gives <code class="notranslate">w = (t-K)^^3</code>, and then move the center upwards to Wmax, then we have <code class="notranslate">w = (t-K)^^3 + Wmax</code>, and we can tune the shape via parameter C, the larger C, more aggressive on the steps, now we have <strong>equation (1)</strong> <code class="notranslate">w = C*(t-K)^^3 + Wmax</code>.</p>
<p>Say if now we have congestion and the congestion window drops from <code class="notranslate">Wmax</code> to <code class="notranslate">Wmax*(1 - beta)</code>, beta is the window decrease factor. And we assume this point is <code class="notranslate">(0, Wmax*(1 - beta)</code>, then K is actually the time it takes to ramp up back to Wmax. and we can get the <strong>equation (2)</strong>:</p>
<pre class="notranslate"><code class="notranslate">cwnd = Wmax - Wmax * beta = C * (0 - K)^^3 + Wmax
=&gt;  Wmax * beta = C * K^^3 
=&gt;  K = (Wmax * beta / C)^^(1/3)
</code></pre>
<p>That is how we get the eqaution (1) and (2) in the paper.</p>
<p>In each RTT period, we calcuate curent Window size using equation (1), <code class="notranslate">W_curr = W(t + RTT)</code>.</p>
<p>The current window might be to small compared with traditional TCP, and might cause friendly issue(actually no wrose than traditional TCP in anyway), so it will give an estimation of the traditional TCP congestion window after time t, and if the window calcualated using cubic function is smaller than that, it will use the traditional TCP congestion window.</p>
<p>To make it fairness with traditional TCP, we should get similar average window size.</p>
<p>The average window size of AIMD additive increase (alpha) and multplicative decrease (beta) is give as <code class="notranslate">sqrt[alpha/2 * (2-beta)/beta / p] / RTT</code>, for tcp alpha = 1 and beta = 0.5, so we have average window size for traditional TCP <code class="notranslate">sqrt(3/2/p) / RTT</code>. Since now in use different beta (0.2) for cubic, to get similiar average window size, the alpha should be <code class="notranslate">3 * beta / (2 - beta)</code>, and we can caculate the window size if using AIMD with alpha and beta, given the elapsed time t since last decrease.</p>
<pre class="notranslate"><code class="notranslate">Wtcp = Wmax * (1-beta) + alpha * t / RTT = Wmax * (1-beta) + 3 * beta / (2-beta) * t / RTT
</code></pre>
<p>fast convergence is used to let new flow to get its fair share more quickly, the idea is that when loss event occurrs, if the Wmax keeps dropping (less than before), it will reduce more to apply a factor <code class="notranslate">1 - beta/2</code> (that is * 0.9), so that the flow have the plateau earlier to give other flows more chance to catch up.</p>
<h1>Linux implementation</h1>
<p>At a first glance, the Linux implementation looks more complicate than the paper, the reason is that for kernel peformance, for example it convert all the float number operation into integer by scaling, and also the congestion avoidance implementation is actually increase the congestion window by 1 every N ACKs, it won't be able to increase by a float number calculated using the equation (1), we have to calculate a N to approximate that to achieve similar effect, and need to consider the effect of delay-ack. Another confusing thing is that the beta in linux implementation is actually 1-beta in the paper. The code also include the hystart slow start algorithm which is not in the cubic paper.</p>
<p>First, let's see how the code use the equations above, the first thing is when there is a packet drop, it will update <code class="notranslate">ssthresh</code> and <code class="notranslate">last_max_cwnd</code>, beta is 717 and BICTCP_BETA_SCALE is 1024, beta/BICTCP_BETA_SCALE = 0.7, so the <code class="notranslate">snd_ssthresh</code> will drop to <code class="notranslate">0.7 * snd_cwnd</code>. And <code class="notranslate">snd_cwnd</code> will be updated based on the state of TCP (todo add more details, see tcp_input.c)</p>
<p>If no fast convergence, <code class="notranslate">last_max_cwnd</code> will set to the current <code class="notranslate">snd_cwnd</code>, otherwise it will apply another factor: <code class="notranslate">(BICTCP_BETA_SCALE + beta) / (2 * BICTCP_BETA_SCALE) = (1+beta_before_scaled)/2 = (1+1-beta_in_paper)/2 = (2 - beta_in_paper)/2 = (1 - beta_in_paper/2</code></p>
<pre class="notranslate"><code class="notranslate">static u32 bictcp_recalc_ssthresh(struct sock *sk)
{
	const struct tcp_sock *tp = tcp_sk(sk);
	struct bictcp *ca = inet_csk_ca(sk);

	ca-&gt;epoch_start = 0;	/* end of epoch */

	/* Wmax and fast convergence */
	if (tp-&gt;snd_cwnd &lt; ca-&gt;last_max_cwnd &amp;&amp; fast_convergence)
		ca-&gt;last_max_cwnd = (tp-&gt;snd_cwnd * (BICTCP_BETA_SCALE + beta))
			/ (2 * BICTCP_BETA_SCALE);
	else
		ca-&gt;last_max_cwnd = tp-&gt;snd_cwnd;

	ca-&gt;loss_cwnd = tp-&gt;snd_cwnd;

	return max((tp-&gt;snd_cwnd * beta) / BICTCP_BETA_SCALE, 2U);
}
</code></pre>
<p>When get ack, it will calculate a moving average of delayed acked packet count <code class="notranslate">delayed_ack</code>, <code class="notranslate">ACK_RATIO_SHIFT</code>(default to 4) is the moving average factor and <code class="notranslate">cnt</code> is the delayed acked packet count in current ACK. <code class="notranslate">delayed_ack</code> will be used later to update congestion window, in the paper it assumes that we update congestion window on each ACK per RTT, and delayed ack might gives longer interval per ACK, and we need compensate for that.</p>
<p>The following code is actuall doing the math <code class="notranslate">ratio = (15*ratio + sample) / 16</code>, <code class="notranslate">delayed_ack</code>(ratio) is initilized to be 16 times larger <code class="notranslate">ca-&gt;delayed_ack = 2 &lt;&lt; ACK_RATIO_SHIFT;</code>, if the last value is X without scaling by 16 times (<code class="notranslate">ratio = 16 * X</code>), then <code class="notranslate">15 * ratio / 16 + cnt = 15 * 16 * X / 16 + cnt = 15 * X + cnt</code>, <code class="notranslate">15 * ratio / 16 + cnt</code> is what used in the code below, and if we check the above equation in reverse direction: moving average of the raw value X without scaling is <code class="notranslate">(15 * X + cnt) / 16 = (15 * 16 * X / 16 + cnt) / 16 = (15 * ratio / 16 + cnt) / 16</code>, that is we can calculate moving average X using the scaled value ratio, and we need <code class="notranslate">* 16</code> to convert the raw value to <code class="notranslate">ratio</code> for next iteration, and store that in <code class="notranslate">delayed_ack</code>, so the <code class="notranslate">delayed_ack</code> is actually the moving avarege of scaled value.</p>
<pre class="notranslate"><code class="notranslate">static void bictcp_acked(struct sock *sk, u32 cnt, s32 rtt_us)
{
    ......
                u32 ratio = ca-&gt;delayed_ack;
		ratio -= ca-&gt;delayed_ack &gt;&gt; ACK_RATIO_SHIFT;
		ratio += cnt;
		ca-&gt;delayed_ack = min(ratio, ACK_RATIO_LIMIT);
    ......
}
</code></pre>
<p>If the current <code class="notranslate">snd_cwnd</code> is no larger than <code class="notranslate">snd_ssthresh</code> it will enter into slow start, can either use the traditional slow start or hystart based on the settings, otherwise, it will enter into congestion avoidance, this is what cubic does most of its job:</p>
<p>If current <code class="notranslate">cwnd</code> is larger than <code class="notranslate">last_max_cwnd</code>, will reset the origin point to <code class="notranslate">cwnd</code>, and reset <code class="notranslate">bic_K</code> to zero, this is the max probing state. Else it's in steady state, and will compute new K, the estimate time needed to reach <code class="notranslate">last_max_cwnd</code>, we can rewrite equation 2 <code class="notranslate">cwnd = Wmax - Wmax * beta = C * (0 - K)^^3 + Wmax =&gt; K = [(Wmax - cwnd) / C]^^(1/3)</code>, this is the equation used in the code.</p>
<pre class="notranslate"><code class="notranslate">    if (ca-&gt;last_max_cwnd &lt;= cwnd) {
			ca-&gt;bic_K = 0;
			ca-&gt;bic_origin_point = cwnd;
		} else {
			/* Compute new K based on
			 * (wmax-cwnd) * (srtt&gt;&gt;3 / HZ) / c * 2^(3*bictcp_HZ)
			 */
			ca-&gt;bic_K = cubic_root(cube_factor
					       * (ca-&gt;last_max_cwnd - cwnd));
			ca-&gt;bic_origin_point = ca-&gt;last_max_cwnd;
		}
</code></pre>
<p>should be notice that the unit of bic_K (same for the elapsed time since epoch) is not ms nor jiffies(HZ), it's using <code class="notranslate">BHZ = HZ*(2^^BICTCP_HZ) = HZ*(2^^10) = HZ*1024</code>, to avoid overflow when doing the math.</p>
<p>The C used is actually <code class="notranslate">bic_scale * 10 / 1024 =  41 * 10 / 1024 =  0.4</code>, and in order to convert the time to units of BHZ, <code class="notranslate">bic_K (HZ) = cubic_root(1/C * (last_max_cwnd - cwnd)) =&gt; bic_K (BHz) * 2^^BICTCP_HZ = 2^^BICTCP_HZ * cubic_root(1/C * (last_max_cwnd - cwnd)) = cubic_root((2^^BICTCP_HZ)^^3 * 1/C * (last_max_cwnd - cwnd)) = cubic_root(2^^(3*BICTCP_HZ) * 1/C * (last_max_cwnd - cwnd)) = cubic_root(2^^(3*BICTCP_HZ) * 2^^10/(bic_scale*10) * (last_max_cwnd - cwnd))</code></p>
<p><code class="notranslate">2^^(3*BICTCP_HZ) * 2^^10/(bic_scale*10) = 2^^(3*BICTCP_HZ+10)/(bic_scale*10) = 1ull &lt;&lt; (10+3*BICTCP_HZ)/(bic_scale*10)</code>, this is how <code class="notranslate">cube_factor</code> is caculated.</p>
<pre class="notranslate"><code class="notranslate">cube_factor = 1ull &lt;&lt; (10+3*BICTCP_HZ);
do_div(cube_factor, bic_scale * 10);
</code></pre>
<p>Then we will caculate the elapsed time plus one RTT in unit BHZ, and then caculate the target congestion window, for calculating delta of congestion window, <code class="notranslate">delta = (cube_rtt_scale * offs * offs * offs) &gt;&gt; (10+3*BICTCP_HZ);</code>, since the <code class="notranslate">offset</code> is in BHZ, to convert it back to HZ, we need <code class="notranslate">/ (2^^BICTCP_HZ)</code>, that is <code class="notranslate">&gt;&gt;BICTCP_HZ</code>, and we have multiplied 3 offset, so it's converting 'BHZ * BHZ * BHZ' back to 'HZ * HZ * HZ', that is <code class="notranslate">/(2^^BICTCP_HZ)^^3 = /(2^^(3*BICTCP_HZ) = &gt;&gt;(3*BICTCP_HZ)</code>, and <code class="notranslate">C = cube_rtt_scale/1024 = cube_rtt_scale &gt;&gt; 10</code>.</p>
<p>so <code class="notranslate">delta = C * offs * offs * offs &gt;&gt; (3+BICTCP_HZ) = cube_rtt_scale * offs * offs * offs &gt;&gt; (10+3*BICTCP_HZ)</code></p>
<pre class="notranslate"><code class="notranslate">	t = ((tcp_time_stamp + msecs_to_jiffies(ca-&gt;delay_min&gt;&gt;3)
	      - ca-&gt;epoch_start) &lt;&lt; BICTCP_HZ) / HZ;

	if (t &lt; ca-&gt;bic_K)		/* t - K */
		offs = ca-&gt;bic_K - t;
	else
		offs = t - ca-&gt;bic_K;

	/* c/rtt * (t-K)^3 */
	delta = (cube_rtt_scale * offs * offs * offs) &gt;&gt; (10+3*BICTCP_HZ);
	if (t &lt; ca-&gt;bic_K)                                	/* below origin*/
		bic_target = ca-&gt;bic_origin_point - delta;
	else                                                	/* above origin*/
		bic_target = ca-&gt;bic_origin_point + delta
</code></pre>
<p>Once we have <code class="notranslate">bic_target</code>, we can calculate the congestion window increment for each RTT, <code class="notranslate">tcp_cong_avoid_ai</code> is called for each ACK, and it will increase <code class="notranslate">snd_cwnd</code> by 1 on every <code class="notranslate">w</code> ACKs (that is increase by <code class="notranslate">1/w</code> on each ACK), for TCP reno <code class="notranslate">w</code> is the congestion window, that is increment by 1 for each RTT (receive <code class="notranslate">w</code> ACKs when <code class="notranslate">w</code> packets send out in one RTT).</p>
<pre class="notranslate"><code class="notranslate">/* In theory this is tp-&gt;snd_cwnd += 1 / tp-&gt;snd_cwnd (or alternative w) */
void tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w)
{
	if (tp-&gt;snd_cwnd_cnt &gt;= w) {
		if (tp-&gt;snd_cwnd &lt; tp-&gt;snd_cwnd_clamp)
			tp-&gt;snd_cwnd++;
		tp-&gt;snd_cwnd_cnt = 0;
	} else {
		tp-&gt;snd_cwnd_cnt++;
	}
}
</code></pre>
<p>For cubic, we are expecting to increase the congestion window by <code class="notranslate">bic_target - cwnd</code> in the next round trip time, since we will send out <code class="notranslate">cwnd</code> packets in one RTT, if we don't consider delayed ack and assume ack per packet, then it's for each ACK the congestion window increases by <code class="notranslate">(bic_target - cwnd)/cwnd</code>, then <code class="notranslate">(bic_target - cwnd)/cwnd = 1/w =&gt; w = cwnd/ (bic_target - cwnd)</code>, which is exactly what we have for <code class="notranslate">ca-&gt;cnt</code> when <code class="notranslate">bic_target &gt; cwnd</code>, if it's smaller, then the increment will be very small, <code class="notranslate">1/(100 * cwnd)</code> on each ACK, that is <code class="notranslate">1/100</code> on each RTT if no delay ACK, this is just a safety guard.</p>
<pre class="notranslate"><code class="notranslate">	/* cubic function - calc bictcp_cnt*/
	if (bic_target &gt; cwnd) {
		ca-&gt;cnt = cwnd / (bic_target - cwnd);
	} else {
		ca-&gt;cnt = 100 * cwnd;              /* very small increment*/
	}
	
	...
	tcp_cong_avoid_ai(tp, ca-&gt;cnt);
</code></pre>
<p>And if we consider the delay ack, we should compensate for that b/c we may get less Ack when using delay ack, which means for each ACK we should increase more, that said if no delay ACK, we increase <code class="notranslate">1/ca-&gt;cnt</code> per ACK (w = ca-&gt;cnt), then with delay ACK, assume we have pkts_per_ack, we should increase <code class="notranslate">pkts_per_ack/ca-&gt;cnt</code> per ACK (w = ca-&gt;cnt/pktsPerAck . <code class="notranslate">delayed_ack</code> is a scaled value, then <code class="notranslate">pkts_per_ack = delayed_ack/16</code></p>
<pre class="notranslate"><code class="notranslate">ca-&gt;cnt = (ca-&gt;cnt &lt;&lt; ACK_RATIO_SHIFT) / ca-&gt;delayed_ack;
</code></pre>
<p>To avoid the case cubic is slower than TCP, it will estimated the congestion window of traditional TCP. In the paper we have the increament factor <code class="notranslate">alpha = 3 * beta_in_paper / (2-beta_in_paper)</code>, since in the code the beta is actual <code class="notranslate">1-beta_in_paper</code>, then <code class="notranslate">alpha = 3 * (1 - beta) / (1 + beta)</code>.</p>
<p>in the code, <code class="notranslate">beta_scale = 8 / alpha</code>, 8 is just another scaling factor which ensure beta_scale is integer, and for later use it will apply <code class="notranslate">&gt;&gt;3</code> which give <code class="notranslate">1 / alpha</code>.</p>
<pre class="notranslate"><code class="notranslate">beta_scale = 8*(BICTCP_BETA_SCALE+beta)/ 3 / (BICTCP_BETA_SCALE - beta);
</code></pre>
<p>When <code class="notranslate">tcp_friendliness</code> enabled, to simulate traditional TCP, the congestion window increase per RTT is <code class="notranslate">alpha</code>, so for each ACK, the increment <code class="notranslate">1/w</code> is <code class="notranslate">alpha/cwnd = 8/(beta_scale * cwnd)</code>, so we have <code class="notranslate">w = beta_scale * cwnd / 8 = beta_scale * cwnd &gt;&gt; 3</code>. That is every <code class="notranslate">w</code> ACK packets the congestion window increment by 1, give current has <code class="notranslate">ca-&gt;ack_cnt</code> acks in total, we can estimate <code class="notranslate">tcp_cwnd</code>.</p>
<p>once we have <code class="notranslate">tcp_cwnd</code>, if it's larger than current <code class="notranslate">cwnd</code>, we should increase cwnd by <code class="notranslate">delta = tcp_cwnd - cwnd</code>, and we use the max between <code class="notranslate">bic_target</code> and <code class="notranslate">tcp_cwnd</code>, the code is using smaller cnt but it's actually the same.</p>
<pre class="notranslate"><code class="notranslate">	/* TCP Friendly */
	if (tcp_friendliness) {
		u32 scale = beta_scale;
		delta = (cwnd * scale) &gt;&gt; 3;
		while (ca-&gt;ack_cnt &gt; delta) {		/* update tcp cwnd */
			ca-&gt;ack_cnt -= delta;
			ca-&gt;tcp_cwnd++;
		}

		if (ca-&gt;tcp_cwnd &gt; cwnd){	/* if bic is slower than tcp */
			delta = ca-&gt;tcp_cwnd - cwnd;
			max_cnt = cwnd / delta;
			if (ca-&gt;cnt &gt; max_cnt)
				ca-&gt;cnt = max_cnt;
		}
	}
</code></pre>
<h1>Hystart</h1>
<p>Linux implementation also use hystart slow start by default, hystart slow start is to exit early to avoid too many packet loss caused by slow start phase, and it utilize the packet train and delay to give hint when to stop slow start. Since for most TCP it's window based and data are send out in a burst in one congestion window, which means we can use those packets as packet train, suppose we send out N packets in the train, the time gap between the 1st and Nst packet is delta(N), then the bandwidth estimation will be <code class="notranslate">bw = (N-1) * packet_length / delta(N)</code>,  the network pipe capcaity (without buffer) is <code class="notranslate">K = bw * one_way_delay_min</code>, the data sent in a cwnd should be no larger than the pipe capacity.</p>
<pre class="notranslate"><code class="notranslate">(N-1) * packet_length &lt;= bw * one_way_delay_min = (N-1) * packet_length / delta(N) * one_way_delay_min
=&gt; delta(N) &lt;= one_way_delay_min
</code></pre>
<p>That means we can measure the time gap of the train to know whether we are exceed the available bandwidth and enter into congestion avoidance. Since it's not easy to measure one way delay, half of RTT is used, and to avoid modification on both sides, ACK gap between Nst and 1st packet is used.</p>
<p>Using RTT/2 as one way delay estimation won't make things worse,  exit too early will cause under untilization, <code class="notranslate">beta * (bw * one_way_delay_min)</code> can be used as the lowerbound for safety exit, for standard TCP, beta is 0.5, other variances has beta larger than 0.5;</p>
<p>suppose we have forward and backward delay <code class="notranslate">a</code> and <code class="notranslate">b</code>, if we use <code class="notranslate">RTT/2 = (a+b)/2</code> as one way delay, the BDP estimation <code class="notranslate">K' = bw * (a+b)/2</code> while <code class="notranslate">K =  bw * a</code>, <code class="notranslate">K'/K = (a + b) / 2 / a = 1/2 + b/2/a &gt;= 1/2</code>, so we have <code class="notranslate">K' &gt;= 0.5 * K</code>, that is to say if we use RTT/2 as estimation, the BDP estimations is no less than half of the real BDP, so we won't exit slow start before we reach 0.5 * BDP (threshold of the standard TCP slow start).</p>
<p>And if it congestin window goes beyond <code class="notranslate">K + S</code>(S is network buffer size), which is the upper bound of safety exit, packet will be dropped, so we have <code class="notranslate">K'/K = 1/2 + b/2/a &lt;= (K + S)/K =&gt; 1/2 + b/2/a &lt;= 1 + S/K</code>, if <code class="notranslate">S=K</code>, then <code class="notranslate">1/2 + b/2/a &lt;= 2 =&gt; b/a &lt;= 3 =&gt; b &lt;= 3a</code>, and there are less than 5% cases that has reverse path delay larger than forward path, which means in this case, the slow start will fallback to traditional slow start which overshoots and cause packet loss.</p>
<p>Using Ack may give larger time gap, which gives lower bandwidth estimation, and cause conservative behavior to exit slow start earlier. Delay Ack also affect the accuracy, so if there is significantly delay in the last ACK, that sample is filter out and mixed with next train.</p>
<p>And there may be cases that minimum RTT is not available, for example when multiple flows are competing, the idea is use delay increasing as an exit indicator, it measure the first a few packets of the train, and calculate the average RTT for that train, and compare the trian K and train K-1, if RTT(K) &gt; RTT(K-1) + delta, then exit slow start.</p>
<p>The Linux implementation is slightly different and simpler than that in the paper.</p>
<p>Hystart will be triggered when the cwnd is larger than <code class="notranslate">hystart_low_window</code> (default to 16)</p>
<pre class="notranslate"><code class="notranslate">	/* hystart triggers when cwnd is larger than some threshold */
	if (hystart &amp;&amp; tp-&gt;snd_cwnd &lt;= tp-&gt;snd_ssthresh &amp;&amp;
	    tp-&gt;snd_cwnd &gt;= hystart_low_window)
		hystart_update(sk, delay);
</code></pre>
<p>It will keep track to minimum delay(<code class="notranslate">delay_min</code>) in the tcp session so far. On each ACK, it will check if the time since last ACK is less than the threshold <code class="notranslate">hystart_ack_delta</code> to filter the invalid sample, if it's invalid, then in this round, it will not do ack train detection, and if the sample is valid, check if it goes beyond minRTT/2 (<code class="notranslate">delay_min</code> is scaled by 8, so <code class="notranslate">&gt;&gt;4</code> is actually minRTT/2), if so it will detect as <code class="notranslate">HYSTART_ACK_TRAIN</code> happens.</p>
<p>It also track minimum delay(<code class="notranslate">curr_delay</code>) among the first <code class="notranslate">HYSTART_MIN_SAMPLES</code> samples in each round (send cwnd packets in the burst train). It <code class="notranslate">curr_delay</code> is larger than <code class="notranslate">delay_min</code> more than a threshold value, which is <code class="notranslate">delay_min/2</code>, clamp to <code class="notranslate">[4, 16] ms</code>, then it will detect as <code class="notranslate">HYSTART_DELAY</code>.</p>
<p>Either one detected will cause the slow start exit by setting the <code class="notranslate">ssthresh</code> to current congeston window <code class="notranslate">snd_cwnd</code>.</p>
<pre class="notranslate"><code class="notranslate">static void hystart_update(struct sock *sk, u32 delay)
{
	struct tcp_sock *tp = tcp_sk(sk);
	struct bictcp *ca = inet_csk_ca(sk);

	if (!(ca-&gt;found &amp; hystart_detect)) {
		u32 now = bictcp_clock();

		/* first detection parameter - ack-train detection */
		if ((s32)(now - ca-&gt;last_ack) &lt;= hystart_ack_delta) {
			ca-&gt;last_ack = now;
			if ((s32)(now - ca-&gt;round_start) &gt; ca-&gt;delay_min &gt;&gt; 4)
				ca-&gt;found |= HYSTART_ACK_TRAIN;
		}

		/* obtain the minimum delay of more than sampling packets */
		if (ca-&gt;sample_cnt &lt; HYSTART_MIN_SAMPLES) {
			if (ca-&gt;curr_rtt == 0 || ca-&gt;curr_rtt &gt; delay)
				ca-&gt;curr_rtt = delay;

			ca-&gt;sample_cnt++;
		} else {
			if (ca-&gt;curr_rtt &gt; ca-&gt;delay_min +
			    HYSTART_DELAY_THRESH(ca-&gt;delay_min&gt;&gt;4))
				ca-&gt;found |= HYSTART_DELAY;
		}
		/*
		 * Either one of two conditions are met,
		 * we exit from slow start immediately.
		 */
		if (ca-&gt;found &amp; hystart_detect)
			tp-&gt;snd_ssthresh = tp-&gt;snd_cwnd;
	}
}
</code></pre>
<h1>Tuning parameters</h1>
<p>Linux cubic implementation has some parameters which can be used to tune the algorithm, by set different values for files (filename is the same with parameter name) in <code class="notranslate">/sys/module/tcp_cubic/parameters/</code></p>
<ul>
<li>
<p>fast_convergence: default is on. enable fast convergence will degrade more when consecutive downgrade, this is used for let new comers to get fair share faster.</p>
</li>
<li>
<p>beta: beta is used for multiplicative decrease, larger value will decrease less, default is 0.7, that is 0.7 * cwnd when loss happens. beta will also affect the fairness with standard TCP. beta is scaled by 1024.</p>
</li>
<li>
<p>initial_ssthresh: use to set the initial ssthresh value, only used at the beginning whe hystart not enabled.</p>
</li>
<li>
<p>bic_scale: bi_scale is used to tune the cubic funtion curve (C in the equation 1), large beta will increase more aggressively, default is 0.4. bic_scale also affect teh fairness with standard TCP. bic_scale is scaled by 1024.</p>
</li>
<li>
<p>tcp_friendliness: used to ensure in any case cubic is no worse than standard TCP. default is on.</p>
</li>
<li>
<p>hystart: enable hystart, which exit slow start earlier based on delay to avoid too much packet loss.</p>
</li>
<li>
<p>hystart_detect: enable which methods are used for hystart detection, default is enable both packet train and delay increase.</p>
</li>
<li>
<p>hystart_low_window: when cwnd is larger than hystart_low_window, will start hystart slow start. default is 16.</p>
</li>
<li>
<p>hystart_ack_delta: threshold value to filter delay ACK, default is 2.</p>
</li>
</ul>
<pre class="notranslate"><code class="notranslate">module_param(fast_convergence, int, 0644);
MODULE_PARM_DESC(fast_convergence, "turn on/off fast convergence");
module_param(beta, int, 0644);
MODULE_PARM_DESC(beta, "beta for multiplicative increase");
module_param(initial_ssthresh, int, 0644);
MODULE_PARM_DESC(initial_ssthresh, "initial value of slow start threshold");
module_param(bic_scale, int, 0444);
MODULE_PARM_DESC(bic_scale, "scale (scaled by 1024) value for bic function (bic_scale/1024)");
module_param(tcp_friendliness, int, 0644);
MODULE_PARM_DESC(tcp_friendliness, "turn on/off tcp friendliness");
module_param(hystart, int, 0644);
MODULE_PARM_DESC(hystart, "turn on/off hybrid slow start algorithm");
module_param(hystart_detect, int, 0644);
MODULE_PARM_DESC(hystart_detect, "hyrbrid slow start detection mechanisms"
		 " 1: packet-train 2: delay 3: both packet-train and delay");
module_param(hystart_low_window, int, 0644);
MODULE_PARM_DESC(hystart_low_window, "lower bound cwnd for hybrid slow start");
module_param(hystart_ack_delta, int, 0644);
MODULE_PARM_DESC(hystart_ack_delta, "spacing between ack's indicating train (msecs)");
</code></pre></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://jiantaofu.github.io">The Curious Path</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","JiantaoFu/jiantaofu.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script>

</html>
