{"singlePage": [], "startSite": "", "filingNum": "", "onePageListNum": 15, "commentLabelColor": "#006b75", "yearColorList": ["#bc4c00", "#0969da", "#1f883d", "#A333D0"], "i18n": "CN", "themeMode": "manual", "dayTheme": "light", "nightTheme": "dark", "urlMode": "pinyin", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script>", "style": "", "head": "", "indexScript": "", "indexStyle": "", "bottomText": "", "showPostSource": 1, "iconList": {}, "UTC": 8, "rssSplit": "sentence", "exlink": {}, "needComment": 1, "allHead": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekVercount.js'></script>", "title": "The Curious Path", "subTitle": "\u597d\u5947\u7684\u63a2\u7d22\u4e4b\u8def", "avatarUrl": "https://www.gravatar.com/avatar/b2e648e70e0d3d2b8970e089ec487bc9?s=200&d=identicon&r=g", "GMEEK_VERSION": "last", "postListJson": {"P1": {"htmlDir": "docs/post/The Pragmatic Programmer-du-hou-gan.html", "labels": ["books"], "postTitle": "The Pragmatic Programmer\u8bfb\u540e\u611f", "postUrl": "post/The%20Pragmatic%20Programmer-du-hou-gan.html", "postSourceUrl": "https://github.com/JiantaoFu/jiantaofu.github.io/issues/1", "commentNum": 0, "wordCount": 11533, "description": "\u8fd9\u672c\u4e66\u7684\u526f\u6807\u9898\u662fFrom Journeyman to Master\uff0c\u4e2d\u6587\u7ffb\u8bd1\u8fc7\u6765\u662f\u201d\u4ece\u5c0f\u5de5\u5230\u4e13\u5bb6\u201d\uff0c\u5de5\u4f5c\u4e86\u8fd1\u5341\u5e74\uff0c\u56de\u8fc7\u5934\u6765\u518d\u770b\u8fd9\u672c\u4e66\uff0c\u53d1\u73b0\u8fd9\u672c\u4e66\u867d\u7136\u4ece\u51fa\u7248\u5230\u73b0\u5728\u5df2\u7ecf\u8fd120\u5e74\u4e86\uff0c\u6b63\u5982\u4f5c\u8005\u572809\u5e74\u7684\u518d\u7248\u5e8f\u8a00\u91cc\u8bf4\u7684:\u201dThings Really Haven\u2019t Changed That Much\u201d\uff0c\u53c8\u4e00\u4e2a\u5341\u5e74\u8fc7\u53bb\u4e86\uff0c\u4e66\u4e2d\u7684\u6700\u4f73\u5b9e\u8df5\u653e\u5012\u4eca\u5929\u4f9d\u7136\u9002\u7528\u3002", "top": 0, "createdAt": 1736295107, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script>", "head": "", "ogImage": "https://www.gravatar.com/avatar/b2e648e70e0d3d2b8970e089ec487bc9?s=200&d=identicon&r=g", "createdDate": "2025-01-08", "dateLabelColor": "#0969da"}, "P2": {"htmlDir": "docs/post/ji-ta-he-xian-ji-chu-li-lun.html", "labels": ["music"], "postTitle": "\u5409\u4ed6\u548c\u5f26\u57fa\u7840\u7406\u8bba", "postUrl": "post/ji-ta-he-xian-ji-chu-li-lun.html", "postSourceUrl": "https://github.com/JiantaoFu/jiantaofu.github.io/issues/2", "commentNum": 0, "wordCount": 4849, "description": "## \u97f3\u7b26\r\n\r\n\u97f3\u4e50\u670912\u4e2a\u97f3\u7b26(Note)\uff0c\u6bcf\u4e2a\u97f3\u7b26\u4e4b\u95f4\u9694\u4e00\u4e2a\u534a\u97f3\uff0c\u6bd4\u5982B\u548cC\u4e4b\u95f4\u5c31\u9694\u4e00\u4e2a\u534a\u97f3(H)\uff0cA\u548cB\u4e4b\u95f4\u9694\u4e00\u4e2a\u5168\u97f3(W, \u5373\u4e24\u4e2a\u534a\u97f3):\r\n\r\n A   |  A&#9839;/B&#9837;  |  B  |  C  |  C&#9839;/D&#9837;  |  D  | D&#9839;/E&#9837;  |  E  |  F  |  F&#9839;/G&#9837;  |  G  |  G&#9839;/A&#9837;\r\n:---:|:-------------------:|:---:|:---:|:-------------------:|:---:|:------------------:|:---:|:---:|:-------------------:|:---:|:------------------:\r\n 1   |      2              |  3  |  4  |              5      |  6  |          7         |  8  |  9  |          10         |  11 |         12\r\n \r\n \u97f3\u7b26\u5728\u5409\u4ed6\u4e0a\u7684\u4f4d\u7f6e\uff0c\u4ece\u5de6\u5230\u53f3\u5bf9\u5e940-12\u4e2a\u97f3\u683c(Fred)\uff0c\u4ece\u4e0a\u5230\u4e0b\u5bf9\u5e941-6\u5f26\uff1a\r\n \r\n0 |  1   |      2              |  3  |  4  |              5      |  6  |          7         |  8  |  9  |          10         |  11 \r\n:---:|:-------------------:|:---:|:---:|:-------------------:|:---:|:------------------:|:---:|:---:|:-------------------:|:---:|:------------------:\r\nE | F | F&#9839;/G&#9837; | G | G&#9839;/A&#9837; | A | A&#9839;/B&#9837; | B | C | C&#9839;/D&#9837; | D | D&#9839;/E&#9837; \r\nB | C | C&#9839;/D&#9837; | D | D&#9839;/E&#9837; | E | F | F&#9839;/G&#9837; | G | G&#9839;/A&#9837; | A | A&#9839;/B&#9837; \r\nG | G&#9839;/A&#9837; | A | A&#9839;/B&#9837; | B | C | C&#9839;/D&#9837; | D | D&#9839;/E&#9837; | E | F | F&#9839;/G&#9837; \r\nD | D&#9839;/E&#9837; | E | F | F&#9839;/G&#9837; | G | G&#9839;/A&#9837; | A | A&#9839;/B&#9837; | B | C | C&#9839;/D&#9837; \r\nA | A&#9839;/B&#9837;  | B | C | C&#9839;/D&#9837; | D | D&#9839;/E&#9837; | E | F | F&#9839;/G&#9837; | G | G&#9839;/A&#9837;\r\nE | F | F&#9839;/G&#9837; | G | G&#9839;/A&#9837; | A | A&#9839;/B&#9837; | B | C | C&#9839;/D&#9837; | D | D&#9839;/E&#9837; \r\n\r\n## \u97f3\u9636(Scale)\r\n\r\n\u5e38\u89c1\u7684\u6709\u5927\u8c03\u97f3\u9636\u548c\u5c0f\u8c03\u97f3\u9636\uff0c\u5b83\u4eec\u7684\u533a\u522b\u5728\u4e8e\u5168\u97f3(W)\u548c\u534a\u97f3(H)\u7684\u6392\u5217\u987a\u5e8f\u4e0d\u540c\uff0c\u800c\u8fd9\u79cd\u4e0d\u540c\u7684\u987a\u5e8f\u4f1a\u5e26\u6765\u4e0d\u540c\u7684\u98ce\u683c\u3002", "top": 0, "createdAt": 1736297528, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script>", "head": "", "ogImage": "https://www.gravatar.com/avatar/b2e648e70e0d3d2b8970e089ec487bc9?s=200&d=identicon&r=g", "createdDate": "2025-01-08", "dateLabelColor": "#0969da"}, "P3": {"htmlDir": "docs/post/TCP Cubic Congestion Control Paper and Linux Implementation.html", "labels": ["Linux"], "postTitle": "TCP Cubic Congestion Control Paper and Linux Implementation", "postUrl": "post/TCP%20Cubic%20Congestion%20Control%20Paper%20and%20Linux%20Implementation.html", "postSourceUrl": "https://github.com/JiantaoFu/jiantaofu.github.io/issues/3", "commentNum": 0, "wordCount": 21379, "description": "# Paper\r\n\r\nuse a cubic function to replace the linear window growth to improve performance in high BDP network, also achieved RTT fairness.\r\n\r\ntcp-cubic is succssor of tcp-bic, tcp-bic use binary search to find the avialble bandwidth when congestion happens, and MAY enter an lieaner increasing state (Additive Increase)if it dropped too low, if it passed the maximum window, it goes into max probing state and will do the reverse and grow slowly initially and switch to additive increase if it can't find new maximum window nearby.\r\n\r\nThe problem with tcp-bic is that the growth function is too aggressive for short RTT or low speed network, and different phases (additive increase, binary search, max probing) add complexity in implememting and analyzing.\r\n\r\ntcp-cubic is replacing the phase functions with a unified one function, which is a cubic function of the elapsed time from the last congestion event.\r\n\r\nfor the tcp-cubic function, we can start with `w=t^^3`, which gives the initial shape center at (0, 0), then we can move the center towards the right to K, which gives `w = (t-K)^^3`, and then move the center upwards to Wmax, then we have `w = (t-K)^^3 + Wmax`, and we can tune the shape via parameter C, the larger C, more aggressive on the steps, now we have **equation (1)** `w = C*(t-K)^^3 + Wmax`.\r\n\r\nSay if now we have congestion and the congestion window drops from `Wmax` to `Wmax*(1 - beta)`, beta is the window decrease factor. And we assume this point is `(0, Wmax*(1 - beta)`, then K is actually the time it takes to ramp up back to Wmax. and we can get the **equation (2)**:\r\n\r\n```\r\ncwnd = Wmax - Wmax * beta = C * (0 - K)^^3 + Wmax\r\n=>  Wmax * beta = C * K^^3 \r\n=>  K = (Wmax * beta / C)^^(1/3)\r\n```\r\n\r\nThat is how we get the eqaution (1) and (2) in the paper.\r\n\r\nIn each RTT period, we calcuate curent Window size using equation (1), `W_curr = W(t + RTT)`.\r\n\r\nThe current window might be to small compared with traditional TCP, and might cause friendly issue(actually no wrose than traditional TCP in anyway), so it will give an estimation of the traditional TCP congestion window after time t, and if the window calcualated using cubic function is smaller than that, it will use the traditional TCP congestion window.\r\n\r\nTo make it fairness with traditional TCP, we should get similar average window size. \r\n\r\nThe average window size of AIMD additive increase (alpha) and multplicative decrease (beta) is give as `sqrt[alpha/2 * (2-beta)/beta / p] / RTT`, for tcp alpha = 1 and beta = 0.5, so we have average window size for traditional TCP `sqrt(3/2/p) / RTT`. Since now in use different beta (0.2) for cubic, to get similiar average window size, the alpha should be `3 * beta / (2 - beta)`, and we can caculate the window size if using AIMD with alpha and beta, given the elapsed time t since last decrease.\r\n\r\n```\r\nWtcp = Wmax * (1-beta) + alpha * t / RTT = Wmax * (1-beta) + 3 * beta / (2-beta) * t / RTT\r\n```\r\n\r\nfast convergence is used to let new flow to get its fair share more quickly, the idea is that when loss event occurrs, if the Wmax keeps dropping (less than before), it will reduce more to apply a factor `1 - beta/2` (that is * 0.9), so that the flow have the plateau earlier to give other flows more chance to catch up.\r\n\r\n# Linux implementation\r\n\r\nAt a first glance, the Linux implementation looks more complicate than the paper, the reason is that for kernel peformance, for example it convert all the float number operation into integer by scaling, and also the congestion avoidance implementation is actually increase the congestion window by 1 every N ACKs, it won't be able to increase by a float number calculated using the equation (1), we have to calculate a N to approximate that to achieve similar effect, and need to consider the effect of delay-ack. Another confusing thing is that the beta in linux implementation is actually 1-beta in the paper. The code also include the hystart slow start algorithm which is not in the cubic paper.\r\n\r\nFirst, let's see how the code use the equations above, the first thing is when there is a packet drop, it will update `ssthresh` and `last_max_cwnd`, beta is 717 and BICTCP_BETA_SCALE is 1024, beta/BICTCP_BETA_SCALE = 0.7, so the `snd_ssthresh` will drop to `0.7 * snd_cwnd`. And `snd_cwnd` will be updated based on the state of TCP (todo add more details, see tcp_input.c)\r\n\r\nIf no fast convergence, `last_max_cwnd` will set to the current `snd_cwnd`, otherwise it will apply another factor: `(BICTCP_BETA_SCALE + beta) / (2 * BICTCP_BETA_SCALE) = (1+beta_before_scaled)/2 = (1+1-beta_in_paper)/2 = (2 - beta_in_paper)/2 = (1 - beta_in_paper/2`\r\n\r\n```\r\nstatic u32 bictcp_recalc_ssthresh(struct sock *sk)\r\n{\r\n\tconst struct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct bictcp *ca = inet_csk_ca(sk);\r\n\r\n\tca->epoch_start = 0;\t/* end of epoch */\r\n\r\n\t/* Wmax and fast convergence */\r\n\tif (tp->snd_cwnd < ca->last_max_cwnd && fast_convergence)\r\n\t\tca->last_max_cwnd = (tp->snd_cwnd * (BICTCP_BETA_SCALE + beta))\r\n\t\t\t/ (2 * BICTCP_BETA_SCALE);\r\n\telse\r\n\t\tca->last_max_cwnd = tp->snd_cwnd;\r\n\r\n\tca->loss_cwnd = tp->snd_cwnd;\r\n\r\n\treturn max((tp->snd_cwnd * beta) / BICTCP_BETA_SCALE, 2U);\r\n}\r\n```\r\n\r\nWhen get ack, it will calculate a moving average of delayed acked packet count `delayed_ack`, `ACK_RATIO_SHIFT`(default to 4) is the moving average factor and `cnt` is the delayed acked packet count in current ACK. `delayed_ack` will be used later to update congestion window, in the paper it assumes that we update congestion window on each ACK per RTT, and delayed ack might gives longer interval per ACK, and we need compensate for that.\r\n\r\nThe following code is actuall doing the math `ratio = (15*ratio + sample) / 16`, `delayed_ack`(ratio) is initilized to be 16 times larger `ca->delayed_ack = 2 << ACK_RATIO_SHIFT;`, if the last value is X without scaling by 16 times (`ratio = 16 * X`), then `15 * ratio / 16 + cnt = 15 * 16 * X / 16 + cnt = 15 * X + cnt`, `15 * ratio / 16 + cnt` is what used in the code below, and if we check the above equation in reverse direction: moving average of the raw value X without scaling is `(15 * X + cnt) / 16 = (15 * 16 * X / 16 + cnt) / 16 = (15 * ratio / 16 + cnt) / 16`, that is we can calculate moving average X using the scaled value ratio, and we need `* 16` to convert the raw value to `ratio` for next iteration, and store that in `delayed_ack`, so the `delayed_ack` is actually the moving avarege of scaled value.\r\n\r\n```\r\nstatic void bictcp_acked(struct sock *sk, u32 cnt, s32 rtt_us)\r\n{\r\n    ......\r\n                u32 ratio = ca->delayed_ack;\r\n\t\tratio -= ca->delayed_ack >> ACK_RATIO_SHIFT;\r\n\t\tratio += cnt;\r\n\t\tca->delayed_ack = min(ratio, ACK_RATIO_LIMIT);\r\n    ......\r\n}\r\n```\r\n\r\nIf the current `snd_cwnd` is no larger than `snd_ssthresh` it will enter into slow start, can either use the traditional slow start or hystart based on the settings, otherwise, it will enter into congestion avoidance, this is what cubic does most of its job:\r\n\r\nIf current `cwnd` is larger than `last_max_cwnd`, will reset the origin point to `cwnd`, and reset `bic_K` to zero, this is the max probing state. Else it's in steady state, and will compute new K, the estimate time needed to reach `last_max_cwnd`, we can rewrite equation 2 `cwnd = Wmax - Wmax * beta = C * (0 - K)^^3 + Wmax => K = [(Wmax - cwnd) / C]^^(1/3)`, this is the equation used in the code.\r\n\r\n```\r\n    if (ca->last_max_cwnd <= cwnd) {\r\n\t\t\tca->bic_K = 0;\r\n\t\t\tca->bic_origin_point = cwnd;\r\n\t\t} else {\r\n\t\t\t/* Compute new K based on\r\n\t\t\t * (wmax-cwnd) * (srtt>>3 / HZ) / c * 2^(3*bictcp_HZ)\r\n\t\t\t */\r\n\t\t\tca->bic_K = cubic_root(cube_factor\r\n\t\t\t\t\t       * (ca->last_max_cwnd - cwnd));\r\n\t\t\tca->bic_origin_point = ca->last_max_cwnd;\r\n\t\t}\r\n```\r\n\r\nshould be notice that the unit of bic_K (same for the elapsed time since epoch) is not ms nor jiffies(HZ), it's using `BHZ = HZ*(2^^BICTCP_HZ) = HZ*(2^^10) = HZ*1024`, to avoid overflow when doing the math.\r\n\r\nThe C used is actually `bic_scale * 10 / 1024 =  41 * 10 / 1024 =  0.4`, and in order to convert the time to units of BHZ, `bic_K (HZ) = cubic_root(1/C * (last_max_cwnd - cwnd)) => bic_K (BHz) * 2^^BICTCP_HZ = 2^^BICTCP_HZ * cubic_root(1/C * (last_max_cwnd - cwnd)) = cubic_root((2^^BICTCP_HZ)^^3 * 1/C * (last_max_cwnd - cwnd)) = cubic_root(2^^(3*BICTCP_HZ) * 1/C * (last_max_cwnd - cwnd)) = cubic_root(2^^(3*BICTCP_HZ) * 2^^10/(bic_scale*10) * (last_max_cwnd - cwnd))`\r\n\r\n`2^^(3*BICTCP_HZ) * 2^^10/(bic_scale*10) = 2^^(3*BICTCP_HZ+10)/(bic_scale*10) = 1ull << (10+3*BICTCP_HZ)/(bic_scale*10)`, this is how `cube_factor` is caculated.\r\n\r\n```\r\ncube_factor = 1ull << (10+3*BICTCP_HZ);\r\ndo_div(cube_factor, bic_scale * 10);\r\n```\r\n\r\nThen we will caculate the elapsed time plus one RTT in unit BHZ, and then caculate the target congestion window, for calculating delta of congestion window, `delta = (cube_rtt_scale * offs * offs * offs) >> (10+3*BICTCP_HZ);`, since the `offset` is in BHZ, to convert it back to HZ, we need `/ (2^^BICTCP_HZ)`, that is `>>BICTCP_HZ`, and we have multiplied 3 offset, so it's converting 'BHZ * BHZ * BHZ' back to 'HZ * HZ * HZ', that is `/(2^^BICTCP_HZ)^^3 = /(2^^(3*BICTCP_HZ) = >>(3*BICTCP_HZ)`, and `C = cube_rtt_scale/1024 = cube_rtt_scale >> 10`.\r\n\r\nso `delta = C * offs * offs * offs >> (3+BICTCP_HZ) = cube_rtt_scale * offs * offs * offs >> (10+3*BICTCP_HZ)`\r\n\r\n```\r\n\tt = ((tcp_time_stamp + msecs_to_jiffies(ca->delay_min>>3)\r\n\t      - ca->epoch_start) << BICTCP_HZ) / HZ;\r\n\r\n\tif (t < ca->bic_K)\t\t/* t - K */\r\n\t\toffs = ca->bic_K - t;\r\n\telse\r\n\t\toffs = t - ca->bic_K;\r\n\r\n\t/* c/rtt * (t-K)^3 */\r\n\tdelta = (cube_rtt_scale * offs * offs * offs) >> (10+3*BICTCP_HZ);\r\n\tif (t < ca->bic_K)                                \t/* below origin*/\r\n\t\tbic_target = ca->bic_origin_point - delta;\r\n\telse                                                \t/* above origin*/\r\n\t\tbic_target = ca->bic_origin_point + delta\r\n```\r\n\r\nOnce we have `bic_target`, we can calculate the congestion window increment for each RTT, `tcp_cong_avoid_ai` is called for each ACK, and it will increase `snd_cwnd` by 1 on every `w` ACKs (that is increase by `1/w` on each ACK), for TCP reno `w` is the congestion window, that is increment by 1 for each RTT (receive `w` ACKs when `w` packets send out in one RTT).\r\n\r\n```\r\n/* In theory this is tp->snd_cwnd += 1 / tp->snd_cwnd (or alternative w) */\r\nvoid tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w)\r\n{\r\n\tif (tp->snd_cwnd_cnt >= w) {\r\n\t\tif (tp->snd_cwnd < tp->snd_cwnd_clamp)\r\n\t\t\ttp->snd_cwnd++;\r\n\t\ttp->snd_cwnd_cnt = 0;\r\n\t} else {\r\n\t\ttp->snd_cwnd_cnt++;\r\n\t}\r\n}\r\n```\r\n\r\nFor cubic, we are expecting to increase the congestion window by `bic_target - cwnd` in the next round trip time, since we will send out `cwnd` packets in one RTT, if we don't consider delayed ack and assume ack per packet, then it's for each ACK the congestion window increases by `(bic_target - cwnd)/cwnd`, then `(bic_target - cwnd)/cwnd = 1/w => w = cwnd/ (bic_target - cwnd)`, which is exactly what we have for `ca->cnt` when `bic_target > cwnd`, if it's smaller, then the increment will be very small, `1/(100 * cwnd)` on each ACK, that is `1/100` on each RTT if no delay ACK, this is just a safety guard.\r\n\r\n```\r\n\t/* cubic function - calc bictcp_cnt*/\r\n\tif (bic_target > cwnd) {\r\n\t\tca->cnt = cwnd / (bic_target - cwnd);\r\n\t} else {\r\n\t\tca->cnt = 100 * cwnd;              /* very small increment*/\r\n\t}\r\n\t\r\n\t...\r\n\ttcp_cong_avoid_ai(tp, ca->cnt);\r\n```\r\n\r\nAnd if we consider the delay ack, we should compensate for that b/c we may get less Ack when using delay ack, which means for each ACK we should increase more, that said if no delay ACK, we increase `1/ca->cnt` per ACK (w = ca->cnt), then with delay ACK, assume we have pkts_per_ack, we should increase `pkts_per_ack/ca->cnt` per ACK (w = ca->cnt/pktsPerAck . `delayed_ack` is a scaled value, then `pkts_per_ack = delayed_ack/16`\r\n\r\n```\r\nca->cnt = (ca->cnt << ACK_RATIO_SHIFT) / ca->delayed_ack;\r\n```\r\n\r\nTo avoid the case cubic is slower than TCP, it will estimated the congestion window of traditional TCP. In the paper we have the increament factor `alpha = 3 * beta_in_paper / (2-beta_in_paper)`, since in the code the beta is actual `1-beta_in_paper`, then `alpha = 3 * (1 - beta) / (1 + beta)`.\r\n\r\nin the code, `beta_scale = 8 / alpha`, 8 is just another scaling factor which ensure beta_scale is integer, and for later use it will apply `>>3` which give `1 / alpha`.\r\n\r\n```\r\nbeta_scale = 8*(BICTCP_BETA_SCALE+beta)/ 3 / (BICTCP_BETA_SCALE - beta);\r\n```\r\n\r\nWhen `tcp_friendliness` enabled, to simulate traditional TCP, the congestion window increase per RTT is `alpha`, so for each ACK, the increment `1/w` is `alpha/cwnd = 8/(beta_scale * cwnd)`, so we have `w = beta_scale * cwnd / 8 = beta_scale * cwnd >> 3`. That is every `w` ACK packets the congestion window increment by 1, give current has `ca->ack_cnt` acks in total, we can estimate `tcp_cwnd`.\r\n\r\nonce we have `tcp_cwnd`, if it's larger than current `cwnd`, we should increase cwnd by `delta = tcp_cwnd - cwnd`, and we use the max between `bic_target` and `tcp_cwnd`, the code is using smaller cnt but it's actually the same.\r\n\r\n```\r\n\t/* TCP Friendly */\r\n\tif (tcp_friendliness) {\r\n\t\tu32 scale = beta_scale;\r\n\t\tdelta = (cwnd * scale) >> 3;\r\n\t\twhile (ca->ack_cnt > delta) {\t\t/* update tcp cwnd */\r\n\t\t\tca->ack_cnt -= delta;\r\n\t\t\tca->tcp_cwnd++;\r\n\t\t}\r\n\r\n\t\tif (ca->tcp_cwnd > cwnd){\t/* if bic is slower than tcp */\r\n\t\t\tdelta = ca->tcp_cwnd - cwnd;\r\n\t\t\tmax_cnt = cwnd / delta;\r\n\t\t\tif (ca->cnt > max_cnt)\r\n\t\t\t\tca->cnt = max_cnt;\r\n\t\t}\r\n\t}\r\n```\r\n\r\n# Hystart\r\n\r\nLinux implementation also use hystart slow start by default, hystart slow start is to exit early to avoid too many packet loss caused by slow start phase, and it utilize the packet train and delay to give hint when to stop slow start. Since for most TCP it's window based and data are send out in a burst in one congestion window, which means we can use those packets as packet train, suppose we send out N packets in the train, the time gap between the 1st and Nst packet is delta(N), then the bandwidth estimation will be `bw = (N-1) * packet_length / delta(N)`,  the network pipe capcaity (without buffer) is `K = bw * one_way_delay_min`, the data sent in a cwnd should be no larger than the pipe capacity.\r\n\r\n```\r\n(N-1) * packet_length <= bw * one_way_delay_min = (N-1) * packet_length / delta(N) * one_way_delay_min\r\n=> delta(N) <= one_way_delay_min\r\n```\r\n\r\nThat means we can measure the time gap of the train to know whether we are exceed the available bandwidth and enter into congestion avoidance. Since it's not easy to measure one way delay, half of RTT is used, and to avoid modification on both sides, ACK gap between Nst and 1st packet is used. \r\n\r\nUsing RTT/2 as one way delay estimation won't make things worse,  exit too early will cause under untilization, `beta * (bw * one_way_delay_min)` can be used as the lowerbound for safety exit, for standard TCP, beta is 0.5, other variances has beta larger than 0.5;\r\n\r\nsuppose we have forward and backward delay `a` and `b`, if we use `RTT/2 = (a+b)/2` as one way delay, the BDP estimation `K' = bw * (a+b)/2` while `K =  bw * a`, `K'/K = (a + b) / 2 / a = 1/2 + b/2/a >= 1/2`, so we have `K' >= 0.5 * K`, that is to say if we use RTT/2 as estimation, the BDP estimations is no less than half of the real BDP, so we won't exit slow start before we reach 0.5 * BDP (threshold of the standard TCP slow start).  \r\n\r\nAnd if it congestin window goes beyond `K + S`(S is network buffer size), which is the upper bound of safety exit, packet will be dropped, so we have `K'/K = 1/2 + b/2/a <= (K + S)/K => 1/2 + b/2/a <= 1 + S/K`, if `S=K`, then `1/2 + b/2/a <= 2 => b/a <= 3 => b <= 3a`, and there are less than 5% cases that has reverse path delay larger than forward path, which means in this case, the slow start will fallback to traditional slow start which overshoots and cause packet loss.\r\n\r\nUsing Ack may give larger time gap, which gives lower bandwidth estimation, and cause conservative behavior to exit slow start earlier. Delay Ack also affect the accuracy, so if there is significantly delay in the last ACK, that sample is filter out and mixed with next train.\r\n\r\nAnd there may be cases that minimum RTT is not available, for example when multiple flows are competing, the idea is use delay increasing as an exit indicator, it measure the first a few packets of the train, and calculate the average RTT for that train, and compare the trian K and train K-1, if RTT(K) > RTT(K-1) + delta, then exit slow start.\r\n\r\nThe Linux implementation is slightly different and simpler than that in the paper.\r\n\r\nHystart will be triggered when the cwnd is larger than `hystart_low_window` (default to 16)\r\n\r\n```\r\n\t/* hystart triggers when cwnd is larger than some threshold */\r\n\tif (hystart && tp->snd_cwnd <= tp->snd_ssthresh &&\r\n\t    tp->snd_cwnd >= hystart_low_window)\r\n\t\thystart_update(sk, delay);\r\n```\r\n\r\nIt will keep track to minimum delay(`delay_min`) in the tcp session so far. On each ACK, it will check if the time since last ACK is less than the threshold `hystart_ack_delta` to filter the invalid sample, if it's invalid, then in this round, it will not do ack train detection, and if the sample is valid, check if it goes beyond minRTT/2 (`delay_min` is scaled by 8, so `>>4` is actually minRTT/2), if so it will detect as `HYSTART_ACK_TRAIN` happens.\r\n\r\nIt also track minimum delay(`curr_delay`) among the first `HYSTART_MIN_SAMPLES` samples in each round (send cwnd packets in the burst train). It `curr_delay` is larger than `delay_min` more than a threshold value, which is `delay_min/2`, clamp to `[4, 16] ms`, then it will detect as `HYSTART_DELAY`.\r\n\r\nEither one detected will cause the slow start exit by setting the `ssthresh` to current congeston window `snd_cwnd`.\r\n\r\n```\r\nstatic void hystart_update(struct sock *sk, u32 delay)\r\n{\r\n\tstruct tcp_sock *tp = tcp_sk(sk);\r\n\tstruct bictcp *ca = inet_csk_ca(sk);\r\n\r\n\tif (!(ca->found & hystart_detect)) {\r\n\t\tu32 now = bictcp_clock();\r\n\r\n\t\t/* first detection parameter - ack-train detection */\r\n\t\tif ((s32)(now - ca->last_ack) <= hystart_ack_delta) {\r\n\t\t\tca->last_ack = now;\r\n\t\t\tif ((s32)(now - ca->round_start) > ca->delay_min >> 4)\r\n\t\t\t\tca->found |= HYSTART_ACK_TRAIN;\r\n\t\t}\r\n\r\n\t\t/* obtain the minimum delay of more than sampling packets */\r\n\t\tif (ca->sample_cnt < HYSTART_MIN_SAMPLES) {\r\n\t\t\tif (ca->curr_rtt == 0 || ca->curr_rtt > delay)\r\n\t\t\t\tca->curr_rtt = delay;\r\n\r\n\t\t\tca->sample_cnt++;\r\n\t\t} else {\r\n\t\t\tif (ca->curr_rtt > ca->delay_min +\r\n\t\t\t    HYSTART_DELAY_THRESH(ca->delay_min>>4))\r\n\t\t\t\tca->found |= HYSTART_DELAY;\r\n\t\t}\r\n\t\t/*\r\n\t\t * Either one of two conditions are met,\r\n\t\t * we exit from slow start immediately.\r\n\t\t */\r\n\t\tif (ca->found & hystart_detect)\r\n\t\t\ttp->snd_ssthresh = tp->snd_cwnd;\r\n\t}\r\n}\r\n```\r\n\r\n# Tuning parameters\r\n\r\nLinux cubic implementation has some parameters which can be used to tune the algorithm, by set different values for files (filename is the same with parameter name) in `/sys/module/tcp_cubic/parameters/`\r\n\r\n- fast_convergence: default is on. enable fast convergence will degrade more when consecutive downgrade, this is used for let new comers to get fair share faster. \r\n\r\n- beta: beta is used for multiplicative decrease, larger value will decrease less, default is 0.7, that is 0.7 * cwnd when loss happens. beta will also affect the fairness with standard TCP. beta is scaled by 1024.\r\n\r\n- initial_ssthresh: use to set the initial ssthresh value, only used at the beginning whe hystart not enabled.\r\n\r\n- bic_scale: bi_scale is used to tune the cubic funtion curve (C in the equation 1), large beta will increase more aggressively, default is 0.4. bic_scale also affect teh fairness with standard TCP. bic_scale is scaled by 1024.\r\n\r\n- tcp_friendliness: used to ensure in any case cubic is no worse than standard TCP. default is on.\r\n\r\n- hystart: enable hystart, which exit slow start earlier based on delay to avoid too much packet loss.\r\n\r\n- hystart_detect: enable which methods are used for hystart detection, default is enable both packet train and delay increase.\r\n\r\n- hystart_low_window: when cwnd is larger than hystart_low_window, will start hystart slow start. default is 16.\r\n\r\n- hystart_ack_delta: threshold value to filter delay ACK, default is 2.\r\n\r\n```\r\nmodule_param(fast_convergence, int, 0644);\r\nMODULE_PARM_DESC(fast_convergence, 'turn on/off fast convergence');\r\nmodule_param(beta, int, 0644);\r\nMODULE_PARM_DESC(beta, 'beta for multiplicative increase');\r\nmodule_param(initial_ssthresh, int, 0644);\r\nMODULE_PARM_DESC(initial_ssthresh, 'initial value of slow start threshold');\r\nmodule_param(bic_scale, int, 0444);\r\nMODULE_PARM_DESC(bic_scale, 'scale (scaled by 1024) value for bic function (bic_scale/1024)');\r\nmodule_param(tcp_friendliness, int, 0644);\r\nMODULE_PARM_DESC(tcp_friendliness, 'turn on/off tcp friendliness');\r\nmodule_param(hystart, int, 0644);\r\nMODULE_PARM_DESC(hystart, 'turn on/off hybrid slow start algorithm');\r\nmodule_param(hystart_detect, int, 0644);\r\nMODULE_PARM_DESC(hystart_detect, 'hyrbrid slow start detection mechanisms'\r\n\t\t ' 1: packet-train 2: delay 3: both packet-train and delay');\r\nmodule_param(hystart_low_window, int, 0644);\r\nMODULE_PARM_DESC(hystart_low_window, 'lower bound cwnd for hybrid slow start');\r\nmodule_param(hystart_ack_delta, int, 0644);\r\nMODULE_PARM_DESC(hystart_ack_delta, 'spacing between ack's indicating train (msecs)');\r\n```\u3002", "top": 0, "createdAt": 1736314494, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script>", "head": "", "ogImage": "https://www.gravatar.com/avatar/b2e648e70e0d3d2b8970e089ec487bc9?s=200&d=identicon&r=g", "createdDate": "2025-01-08", "dateLabelColor": "#0969da"}, "P4": {"htmlDir": "docs/post/Piem- Network Emulator based on Raspberry Pi.html", "labels": ["Linux"], "postTitle": "Piem: Network Emulator based on Raspberry Pi", "postUrl": "post/Piem-%20Network%20Emulator%20based%20on%20Raspberry%20Pi.html", "postSourceUrl": "https://github.com/JiantaoFu/jiantaofu.github.io/issues/4", "commentNum": 0, "wordCount": 4182, "description": "# Basic setup\r\n\r\nYou can use [Raspberry Pi 4](https://www.amazon.com/GeeekPi-Raspberry-4GB-Starter-Kit/dp/B0B3M2HKN6/ref=sr_1_12_sspa?crid=2L2JEUJ1460WB&dib=eyJ2IjoiMSJ9.dm2FB5zZz0j71xQemzz3eGcfMj6yAgNj0EPv-ZREy2PWNx49GJkdHYAzErmjO1rWARxfo12XUNdoTscBLFfbLbRIYyt2O44eh6kBKePKgZHoWzqG1x61SEy_n7vicrrWGgnVkLoWBoS1rY0LU453Xc8SXZtyYgzT9ZGvLWKovR1k4qtC_FNH2zz6wdvKDwm1cEi8riFowfxHNBwFO9r6uRsuyK5wCfuxhzNEeM3-ugw.eOUzPFP7-jr6HburUXKHBVMMswaal6qpIhVdoWuOVjI&dib_tag=se&keywords=raspberry+pi+starter+kit&qid=1726551003&sprefix=raspberry+pi+starter+ki%2Caps%2C176&sr=8-12-spons&sp_csd=d2lkZ2V0TmFtZT1zcF9tdGY&psc=1) (or Raspberry Pi 3B) as a network emulator. Raspberry Pi can be used to set up a bridged network, either using ethernet or WiFi.\r\n\r\nYou can [download](https://www.dropbox.com/scl/fi/e02utgcmfw5opfymdq9h7/image_2023-05-10-piem-lite.zip?rlkey=l8b32tgl41zoqa6nupxq2y41r&st=ad66ldbu&dl=0) the prebuild image, and then download [Etcher](https://etcher.io/) and install the image on the micro sdcard.\r\n\r\nOnce done, connect keyboard monitor, and ethernet, boot and login with username \u201cpi\u201d and password \u201craspberry\u201d, then execute the following command to enable WiFi network:\r\n\r\n```\r\nrfkill unblock all\r\n```\r\n\r\nThen reboot, login again and make sure the network is working:\r\n\r\nusing ping command to make sure the internet access is working\r\n\r\nUse cell phone to scan the wifi network and find ssid \u201cpiem\u201d, and login with password \u201cpiemulator\u201d, and make sure the internet access is working\r\n\r\nIf not working, try run `sudo systemctl restart networking.service` and wait a few minutes\r\n\r\nThen you can test network impairment:\r\n\r\nRun speed test on Raspberry Pi\r\n\r\n```\r\nsudo apt install speedtest-cli\r\nspeedtest-cli\r\nRetrieving speedtest.net configuration...\r\nTesting from Comcast Cable (98.37.129.143)...\r\nRetrieving speedtest.net server list...\r\nSelecting best server based on ping...\r\nHosted by Jefferson Union High School District (Daly City, CA) [62.00 km]: 16.523 ms\r\nTesting download speed................................................................................\r\nDownload: 483.86 Mbit/s\r\nTesting upload speed......................................................................................................\r\nUpload: 112.79 Mbit/s\r\n```\r\n\r\n2. Run speed test on cell phone connected with WiFi \u201cpiem\u201d. (The speed test may not be as good as you run it on Raspberry Pi, most likely due to interference, default the channel is set to 1)\r\n\r\n3. Test rate limit, set downlink bandwidth to 3mbps, \u201c192.168.1.185\u201d is the IP address of the cellphone\r\n\r\n```\r\nsudo emulator.py add -b 3000 -f 192.168.1.185 -c downlink\r\n```\r\n\r\n4. Then run speed test on cell phone again to validate the settings\r\n\r\n5. Remove the rate limit and test it again\r\n\r\n```\r\nsudo emulator.py remove -f 192.168.1.185 -c downlink\r\n```\r\n\r\n6. Run sudo emulator.py -h for help\r\n\r\nYou can refer https://github.com/cellsim/piem for more details\r\n\r\n# Performance tune\r\n\r\nModify \u201c/etc/hostapd/hostapd.conf\u201d, change/add the following settings:\r\n\r\n1. Use 5GHz network\r\n2. Search for the channel with the least interferences\r\n3. Enable 802.11n support\r\n4. Enable 802.11ac support\r\n5. Enable QoS support\r\n6. Enable HT40 with short guard intervals\r\n\r\n```\r\nhw_mode=a\r\nchannel=0\r\nieee80211n=1\r\nieee80211ac=1\r\nwmm_enabled=1\r\nht_capab=[HT40+][SHORT-GI-40]\r\n```\r\n\r\nThen restart hostapd:\r\n\r\n```\r\nsudo systemctl restart networking.service\r\n```\r\n\r\nThere are chances that channel = 0 doesn't work (at least for me), and you won't be able to find 'piem' network anymore. You can enable logging by adding the following line in '/etc/default/hostapd':\r\n\r\n```\r\nDAEMON_OPTS='-dd -t -f /tmp/hostapd.log'\r\n```\r\n\r\nRestart hostapd and make sure it runs successfully by checking systemctl status hostapd.service, otherwise check error log.\r\n\r\nIf channel auto selection doesn\u2019t work, change that to channel = 36 or other Non-DFS Channels like: 40, 44, 48, 149, 153, 157, 161, 165. Use the following command on Raspberry Pi to check the channel in use nearby:\r\n\r\n```\r\nsudo iwlist wlan0 scan | grep 'Channel'\r\n```\r\n\r\nAfter making those changes, you should be able to see the performance boost (my test shows 3x improvement, around 60mbps ~ 80mbps).\u3002", "top": 0, "createdAt": 1736372025, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script>", "head": "", "ogImage": "https://www.gravatar.com/avatar/b2e648e70e0d3d2b8970e089ec487bc9?s=200&d=identicon&r=g", "createdDate": "2025-01-09", "dateLabelColor": "#0969da"}}, "singeListJson": {}, "labelColorDict": {"books": "#c2e0c6", "bug": "#d73a4a", "documentation": "#0075ca", "enhancement": "#a2eeef", "invalid": "#e4e669", "Linux": "#f9d0c4", "music": "#6D11DC", "wontfix": "#ffffff"}, "displayTitle": "The Curious Path", "faviconUrl": "https://www.gravatar.com/avatar/b2e648e70e0d3d2b8970e089ec487bc9?s=200&d=identicon&r=g", "ogImage": "https://www.gravatar.com/avatar/b2e648e70e0d3d2b8970e089ec487bc9?s=200&d=identicon&r=g", "primerCSS": "<link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />", "homeUrl": "https://jiantaofu.github.io", "prevUrl": "disabled", "nextUrl": "disabled"}